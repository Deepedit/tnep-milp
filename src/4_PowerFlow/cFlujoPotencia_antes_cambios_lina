classdef cFlujoPotencia < handle
        % clase que representa las subestaciones
    properties
        % handle tiene las variables de todos los elementos, incluso los 
        % fuera de servicio
        handle = struct()
        % Variables de los elementos que estan en servicio en la hora de
        % calculo
        Subestaciones = struct()
        Generadores = struct()
        Lineas = struct()
        Consumos = struct()
        Trafos = struct()
        num = struct() % todos cantidades
        Perdidas = complex(0,0)
        
        Adm
        J
        % BusesConRegPorTrafo: contiene lista con Id de buses con transformadores reguladores
        % TrafosReg: contiene lista con Id de trasformadores reguladores
        BusesConRegPorTrafo = [];
        TrafosReg = [];
        
        NivelDebug = 0
        sbase
        % Número de iteraciones sin cambios en tipo de buses
        % buses de PU a PQ
        MaxNumIter
        NumIterSinCambioPVaPQ
        NumIterDesacoplado
        MaxErrorMW
        Flag
        
		% @Lena: folgende Variable müssen weg. Gx_pf_dc soll aus der Klasse cResultadoEvaluacionSEP.m. In diese Klasse werden die Ergebnisse des DCOPFs gespeichert (habe das Parameter ResultadosDespacho hinzugefügt)
		% Die Variable Dem_pf_dc und Dem_qf_dc sollen aus der Klasse cAdministradorEscenario.m kommen. Wie dort die Daten gespeichert und geholt werden findest du in der Klasse DCOPF.
		% In die Klasse cAdministradorEscenario.m gibt es ein Parameter die heisst "PerfilesConsumo". Dort werden sämtliche Profiles (P und Q) gespeichert. 
		% Jeder Last hat zwei Variable: IndiceAdmEscenarioPerfilP und IndiceAdmEscenarioPerfilQ. Diese Variable geben an, in welcher Zeile im cAdministradorEscenario.m sich die jeweilige Profile befinden
		% Der jeweiligen Last (P oder Q) für den Betriebspunkt po berechnet man wie folgt: Pmax*PerfilesConsumo(po) 
        % Ich habe das Parameter pAdmSc hinzugefügt, damit du diese benutzen kannst. Bitte denke daran, dass das Parameter pAdmSc nicht unbedingt benutzt wird (kann sogar nicht definiert werden).
        % Diese brauchst du nur, wenn du die Lastflussrechnung (LFR) über mehrere Betriebspunkte berechnen sollst. Ist das nicht der Fall, dann brauchst du sie nicht. In diesem Fall soll der LFR die lokale Daten im pSEP nehmen. 
        % Wir benötigen auch einige weitere Funktionen. Im pSEP gibt es die
        % Möglichkeit, "Projekte" zu hinzufügen oder zu löschen (siehe
        % Funktionen "agrega_proyecto" und "elimina_proyecto". In diese
        % Funktionen wird gefragt, ob ein Pointer zur OPF zur Verfügung
        % steht. Falls Ja, werden auch die entsprechenden Variablen
        % aktualisiert (entwerden hinzugefügt oder gelöscht). Dies soll
        % auch hier passieren
        % Noch eine weitere Sache: lasse bitte die Möglichkeit Baterien,
        % Condensatoren und Reaktoren zu berücksichtigen. Einfach so: beim
        % erstellen der Daten, falls eine Baterie, Condensator und/oder
        % Reaktor dabei ist, lass ein Fehler passieren. Damit kann ich das
        % später hinzufügen. Lass uns gucken ob du noch Zeit diese Woche
        % hast. Wenn Ja, kannst du gerne das hinzufügen (ich kann dir
        % zeigen wie, oder eventuell auch der Jaime)
        
        Gx_pf_dc
        Dem_pf_dc
        Dem_qf_dc
		ResultadosDespacho = cResultadoEvaluacionSEP.empty
        pAdmSc = cAdministradorEscenarios.empty

        % Variables por el criterio N-1
        PorcCargaCriterioN1
        ListaLineas
        ListaTrafos
        FlagN1 = false
        
        Adm_init
        Subestaciones_init
		
		% @ Lena: noch was anderes. Bevor die Lastflussrechnung (LFR) berechnet wird, muss man die Anzahl der Sub-systeme determinieren. Ich schlage vor, dass du das entweder direkt beim Konstruktor oder bei der 
		% Ermittlung des Containers. Du kannst gucken, wie die Subsysteme bestimmt werden können, bei der alten Funktion des cSistemaModal. Soll das pSEP mehrehre Subsisteme haben, dann muss jedes (neues) Subsistem 
		% ein Slackgenerator haben. Sonst wird die LFR nicht konvergieren. 
		% Bei der N-1 Überprüfung soll auch das gleiche passieren: du muss zunächst überprüfen, ob es Inselsysteme gibt. In diesem Fall soll auch ein Slackgenerator hinzugeügt werden. 
        % Der Slack soll der grosste Generator des Subsystems sein. Sollte kein Generator vorhanden sein, dann muss nach nichts machen und die gesamte Last des Systems gilt als ENS (energy not served). Diese Daten sollen auch
		% gespeichert werden. 
		
		% Zum Speichern der Ergebnisse sollst du auch die Klasse cResultadoEvaluacionSEP benutzen. Ich habe auch das Parameter hier unten hinzugefügt. Diese Klasse gilt als ein "Container". Du kannst die Parameter "freiwillig"
		% benutzen. Eventuell gibt es einige Parameter, die du nicht brauchst. Einfach leer lassen. Also, fallst du weitere Parameter brauchst, einfach diese hinzufügen. 
		
		% Die Funktion calcula_flujo_potencia( this , po) soll kein "po" benötigen. Bitte hinzufüge eine Funktion die heisst "actualiza_punto_operacion(this, po). Beim Aufruf dieser Funktion soll die neue Daten geladen werden 
		% (bzw. die alte Daten sollten durch die neue Daten ersetzt werden. 
		% Ich habe auch ein Parameter hinzugefügt die heisst "PuntoOperacionActual". Jedes mal, wenn du ein neues Betriebspunkt lädst, sollst du der entsprechende Betriebspunkt hier speichern. Dadurch kann man wissen, 
		% ob man die alten Daten mit dem neuen ersetzen soll (z. B. kann man auch wissen, welche P der Generatoren sich geändert haben. 
		
		% Ich habe auch das Parameter "VariablesInicializadas" hinzugefügt. Mit diesem Parameter weisst du, ob die Containers bereits zur Verfügung stehen oder ob man diese inisialisiert werden müssen
		POActual = 0
		ResultadoFlujoPotencia = cResultadoEvaluacionSEP.empty
		VariablesInicializadas = false
		
    end
    methods
        function this = cFlujoPotencia_struct(sep)
            % Hier beim Konstruktor soll auch das Pointer zur
            % cFlujoPotencia (also "this") im pSEP hinzugefügt werden. Ich
            % habe das entsprechende Parameter hinzugefügt
            
            this.sbase = cParametrosFlujoPotencia().sbase;
            this.MaxNumIter = cParametrosFlujoPotencia().MaxNumIter;
            this.NumIterSinCambioPVaPQ = cParametrosFlujoPotencia().NumIterSinCambioPVaPQ;
            this.NumIterDesacoplado = cParametrosFlujoPotencia().NumIterDesacoplado;
            this.MaxErrorMW = cParametrosFlujoPotencia().MaxErrorMW;
            this.PorcCargaCriterioN1 = cParametrosFlujoPotencia().PorcCargaCriterioN1;
            this.Gx_pf_dc = sep.Gx_pf_dc;
            this.Dem_pf_dc = sep.Dem_pf_dc;
            this.Dem_qf_dc = sep.Dem_qf_dc;
            this.handle = rmfield(sep, {'pParFP','Gx_pf_dc','Dem_pf_dc','Dem_qf_dc','Perdidas'});
        end
        
        function inserta_despacho(this,po)
            % @Lena
            % diese Funktion soll heissen "actualiza_punto_operacion". Die
            % Daten sollen aus pAdmSc kommen
            
            % inserta_despacho: redactar el handle_actual que solamente tiene los 
            % elementos del sistema que son en servicio en este hora po con su 
            % parametros individuales
            if po > 0
                for i=1:this.handle.n.Generadores
                    Pxg = this.Gx_pf_dc(i,po+1);
                    this.handle.Generadores.P0(i) = Pxg;
                    if Pxg==0
                        this.handle.Generadores.EnServicio(i) = this.handle.Generadores.Slack(i);
                    else
                        this.handle.Generadores.EnServicio(i) = true;
                    end
                end
                for i=1:this.handle.n.Consumos
                    Dxp = this.Dem_pf_dc(i,po+1);
                    Dxq = this.Dem_qf_dc(i,po+1);
                    this.handle.Consumos.P0(i) = Dxp;
                    this.handle.Consumos.Q0(i) = Dxq;
                end
            end
           
            this.num.Subestaciones = this.handle.n.Subestaciones;
            this.Subestaciones = this.handle.Subestaciones;
            
            this.num.Generadores = sum(this.handle.Generadores.EnServicio);
            fields = fieldnames(this.handle.Generadores);
            for i = 1:numel(fields)
                this.Generadores.(fields{i}) = [];
                this.Generadores.(fields{i}) = this.handle.Generadores.(fields{i})(this.handle.Generadores.EnServicio);
            end
            this.num.Consumos = sum(this.handle.Consumos.EnServicio);
            fields = fieldnames(this.handle.Consumos);
            for i = 1:numel(fields)
                this.Consumos.(fields{i}) = [];
                this.Consumos.(fields{i}) = this.handle.Consumos.(fields{i})(this.handle.Consumos.EnServicio);
            end
            this.num.Lineas = sum(this.handle.Lineas.EnServicio);
            fields = fieldnames(this.handle.Lineas);
            for i = 1:numel(fields)
                this.Lineas.(fields{i}) = [];
                this.Lineas.(fields{i}) = this.handle.Lineas.(fields{i})(this.handle.Lineas.EnServicio);
            end
            this.num.Trafos = sum(this.handle.Trafos.EnServicio);
            fields = fieldnames(this.handle.Trafos);
            for i = 1:numel(fields)
                this.Trafos.(fields{i}) = [];
                this.Trafos.(fields{i}) = this.handle.Trafos.(fields{i})(this.handle.Trafos.EnServicio);
            end

            % cambio el nombre porque la Id necesita ser el index de la fila
            this.Generadores.Id_real = this.Generadores.Id;
            this.Lineas.Id_real = this.Lineas.Id;
            this.Consumos.Id_real = this.Consumos.Id;
            this.Trafos.Id_real = this.Trafos.Id;

            this.Generadores.Id = (1:this.num.Generadores)';
            this.Lineas.Id = (1:this.num.Lineas)';
            this.Trafos.Id = (1:this.num.Trafos)';
            this.Consumos.Id = (1:this.num.Consumos)';

            this.Subestaciones.Lineas = cell(this.num.Subestaciones,1);
            this.Subestaciones.Trafos = cell(this.num.Subestaciones,1);
            this.Subestaciones.Generadores = cell(this.num.Subestaciones,1);
            this.Subestaciones.Consumos = cell(this.num.Subestaciones,1);

            for i = 1:this.num.Subestaciones
                this.Subestaciones.Lineas(i) = {[this.Lineas.Id(this.Lineas.Bus1 == i)',...
                                                          this.Lineas.Id(this.Lineas.Bus2 == i)']};
                this.Subestaciones.Trafos(i) = {[this.Trafos.Id(this.Trafos.Bus1 == i)',...
                                                          this.Trafos.Id(this.Trafos.Bus2 == i)']};
                this.Subestaciones.Generadores(i) = {this.Generadores.Id(this.Generadores.Bus == i)'};
                this.Subestaciones.Consumos(i) = {this.Consumos.Id(this.Consumos.Bus == i)'};
            end
        end
        
        function [ this ] = calcula_flujo_potencia( this , po)
        % @Lena
        % diese Funktion soll nicht "po" als Eingangsdaten bekommen. Man
        % geht davon aus, dass der po im Rahmen der Funktion
        % "actualiza_punto_operacion" geladen wird (siehe Kommentar oben)
        % Es soll auch überprüft werden, ob die Containers bereits
        % initialisiert wurden (VariablesInicializadas)
        % An dieser Stelle soll man auch wissen, wie viele Sub-systeme
        % gibt. 
        % Frage: warum gibst du "this" zurück?
        
        % calcula_flujo_potencia 
        % astimate las parametros de los elementos en servicio del sistema por la
        % hora po asi que los limites de la flujo potencia y otros son cumplidos
		
        if ~this.FlagN1  % @Lena: por qué siguiente línea depende del FlagN1?
            inserta_despacho(this,po);
        end
        inicializa_variables_fp(this);
        % calcula candidad subsistemas
        nro_subsistema = 1;
        % calcula flujo potencia por cada subsistema
        if ~this.FlagN1
            this.construye_matriz_admitancia();
            this.inicializa_variables();
            this.determina_condiciones_iniciales();
            this.Subestaciones_init = this.Subestaciones;
        end
        
        this.Flag = -1; % valor inicial para subsistema actual
        obliga_verificacion_cambio_pv_pq = false;

        % calcula consumo total que es siempre constante
        h = this.num.Subestaciones; % cantidad Buses
        this.Subestaciones.q_consumo_const = zeros(h,1);
        for i = 1:h
            if ~isempty(this.Subestaciones.Consumos{i})
                Cons = [this.Subestaciones.Consumos{i,:}];
                Cons_vali = this.Consumos.DepVoltaje(Cons) == 0;
                if ~isempty(Cons_vali(Cons_vali))
                    this.Subestaciones.q_consumo_const(i) = this.Subestaciones.q_consumo_const(i) + ...
                        sum(-this.Consumos.Q0(Cons(Cons_vali))./this.sbase);
                end
            end
        end

        iter = 0;
        discreto = false;
        delta_s = zeros(h,2);

        % Ajustar los elementos ajustables (Generadores y Trafos) hasta que se
        % cumplan todos los límites de P,Q
        while true
            ds_total = 0;
            ds_mw_total = 0;
            s_complejo = calcula_s_complejo(this);
            s = [real(s_complejo),imag(s_complejo)];

            if this.NivelDebug > 1
                prot = cProtocolo.getInstance;
                prot.imprime_vector([s(:,1);s(:,2)], 's');
            end

            % cálculo criterio convergencia
            not_slack = (this.Subestaciones.TipoBuses ~= 3);
            delta_s(not_slack,1) = this.Subestaciones.Snom(not_slack,1) - s(not_slack,1);
            passivo_PQ = (this.Subestaciones.TipoBuses < 2);
            delta_s(passivo_PQ,2) = this.Subestaciones.Snom(passivo_PQ,2) - s(passivo_PQ,2);
            ds_total = sum(sum(delta_s));
            ds_mw_total = sum(sum(abs(delta_s)));

            if this.NivelDebug > 0
                prot = cProtocolo.getInstance;
        %         prot.imprime_vector([this.Subestaciones.Snom(:,1); this.Subestaciones.Snom(:,2)], 'Snom');
                prot.imprime_vector([delta_s(:,1);delta_s(:,2)], 'delta_s');
                prot.imprime_valor(ds_total, ['ds_total it ' num2str(iter)]);
                prot.imprime_valor(ds_mw_total, 'ds_mw_total');
            end
            % campo tipo de buses PV --> PQ
            cambio_tipo_buses = false;
            if iter > this.NumIterSinCambioPVaPQ || obliga_verificacion_cambio_pv_pq
                % verificar si es necesario cambio de tipo de buses
                % no es un bus cuyo voltaje es controlado por un trafo
                % bus_PV_V: tiene todos Id de buses que son tipo PV y  no tienen transformadores reguladores 
                bus_PV_V = this.Subestaciones.Id(this.Subestaciones.TipoBuses == 2 & this.Subestaciones.TipoVarControl == 0);
                if ~isempty(bus_PV_V)
                    % q_consumo_agregada: suma de Qfp de todos generadores que controlan la tension de este bus
                    q_consumo_agregada = zeros(length(bus_PV_V),1);
                    for i = 1:length(bus_PV_V)
                        if ~isempty(this.Subestaciones.Generadores(bus_PV_V(i)))
                            gens = [this.Subestaciones.Generadores{bus_PV_V(i),:}];
                            Gen_const = gens(this.Generadores.ControlaTensionFP(gens) == 0);
                            q_consumo_agregada(i) = sum(this.Generadores.Qfp(Gen_const)./this.sbase);
                        end
                    end
                    q_consumo = this.Subestaciones.q_consumo_const(bus_PV_V) + q_consumo_agregada;
                    q_inyeccion = s(bus_PV_V,2) - q_consumo;
                    Qmin = zeros(length(bus_PV_V),1);
                    Qmax = zeros(length(bus_PV_V),1);
                    for n = 1:length(bus_PV_V)
                        gens_ids = [this.Subestaciones.Generadores{bus_PV_V(n)}];
                        gen_control_id = gens_ids(this.Generadores.ControlaTensionFP(gens_ids)== 1);
                        Qmin(n) = sum(this.Generadores.Qmin(gen_control_id));
                        Qmax(n) = sum(this.Generadores.Qmax(gen_control_id));
        %--------------- Change in old code!
        %                 if this.Generadores.Despachable(gen_control_id)
        %                     Qmin(n) = sum(this.Generadores.Qmin(gen_control_id));
        %                     Qmax(n) = sum(this.Generadores.Qmax(gen_control_id));
        %                 else % no dispachable
        %                     Pfp = this.Generadores.Pfp(gen_control_id);
        %                     q_no_disp = sqrt((Pfp/0.9).^2 - Pfp.^2);
        %                     Qmin(n) = sum(-q_no_disp);
        %                     Qmax(n) =  sum(q_no_disp);
        %                 end
                    end
                    % q_min/q_max son vectores con los posibles Q max o min para cada
                    % bus
                    q_min = Qmin/this.sbase;
                    q_max = Qmax/this.sbase;

                    for i = 1:length(q_inyeccion)
                        if (q_inyeccion(i) < q_min(i)) || (q_inyeccion(i) > q_max(i))
                            this.Subestaciones.TipoBuses(bus_PV_V(i)) = 1; % 'PQ'
                            if this.NivelDebug > 1
                                text = ['Cambio bus ' num2str(bus_PV_V(i)) ' de PV a PQ porque inyección se encuentra fuera de rango' ...
                                    '. QInyeción: ' num2str(q_inyeccion(i)) '. Q min: ' num2str(q_min(i)) '. Qmax: ' num2str(q_max(i)) '\n'];
                                cProtocolo.getInstance.imprime_texto(text);
                            end
                            % gens_bus: Ids de Generadores de este bus
                            % gens_control: Id de todos generadores que controlan
                            % gens_nodespach: Id de todos generadores que no son despachable
                            % gens: Id de generadores del bus que controlan
                            % gens2: Id de generadores del bus que controlan y no son despachable
                            gens_bus = [this.Subestaciones.Generadores{bus_PV_V(i)}];
                            gens_control = this.Generadores.Id(this.Generadores.ControlaTension == 1); 
                            gens_nodespach = this.Generadores.Id(this.Generadores.Despachable == 0); 
                            gens = intersect(gens_bus, gens_control); 
                            gens2 = intersect(gens, gens_nodespach); 
                            if q_inyeccion(i) < q_min(i)
                                this.Subestaciones.Snom(bus_PV_V(i),2) = q_min(i) + q_consumo(i);
                                % cambia Q de elementos que controlan
                                % tensión para que queden fijos
                                this.Generadores.ControlaTensionFP(gens) = false;
                                this.Generadores.Qfp(gens) = this.Generadores.Qmin(gens);
                                if ~isempty(gens2)
                                    Pfps = this.Generadores.Pfp(gens2);
                                    this.Generadores.Qfp(gens2)= -sqrt((Pfps/0.9).^2 - Pfps.^2);
                                end
                            else
                                this.Subestaciones.Snom(bus_PV_V(i),2) = q_max(i) + q_consumo(i);
                                this.Generadores.Qfp(gens) = this.Generadores.Qmax(gens);
                                if ~isempty(gens2)
                                    Pfps = this.Generadores.Pfp(gens2);
                                    this.Generadores.Qfp(gens2)= sqrt((Pfps/0.9).^2 - Pfps.^2);
                                end
                            end
                            cambio_tipo_buses = true;
                        end
                    end

                end
        %---------------
                % voltaje controlado por trafo. Hay que verificar que tap está
                % dentro de los límites
                bus_PV_Tap = this.Subestaciones.Id(this.Subestaciones.TipoBuses == 2 & this.Subestaciones.TipoVarControl == 1);
                if ~isempty(bus_PV_Tap)
                    t_tap_actual = this.Subestaciones.VarEstado(bus_PV_Tap,2);
                    trafo = ismember([this.Subestaciones.Trafos{bus_PV_Tap}], this.TrafosReg);
                    id_tap = this.Trafos.IdTapRegulador(trafo);
                    tap_nom = this.Trafos.TapNom(trafo,id_tap);
                    du_tap = this.Trafos.DuTap(trafo,id_tap);
                    tap_actual = (t_tap_actual-1)./du_tap+tap_nom; %trafo.entrega_tap_dado_t(id_tap, t_tap_actual);
                    tap_max = this.Trafos.TapMax(trafo,id_tap);
                    tap_min = this.Trafos.TapMax(trafo,id_tap);

                    % fija trafo en tap máximo
                    tan_grande = tap_actual > tap_max;
                    this.Trafos.TapActual(trafo(tan_grande),id_tap) = tap_max;
                    this.Subestaciones.TipoBuses(bus_PV_Tap(tan_grande)) = 1; %'PQ'
                    this.Subestaciones.TipoVarControl(bus_PV_Tap(tan_grande)) = 0; % 'V'

                    tan_chico = tap_actual < tap_min;
                    this.Trafos.TapActual(trafo(tan_chico),id_tap) = tap_min;
                    this.Subestaciones.TipoBuses(bus_PV_Tap(tan_chico)) = 1; % 'PQ'
                    this.Subestaciones.TipoVarControl(bus_PV_Tap(tan_chico)) = 0; % 'V'
                end
            end

            % criterio de convergencia
            % flujo de potencia convergente cuando:
            % 1. error es menor que valor umbral epsilon
            % 2. no hay transformadores reguladores o estos ya fueron
            %    discretizados y 
            % 3. no hubo cambio en tipo de buses

            if ~isnumeric(ds_mw_total)
                % desviación total de mw no es numérico
        %         convergencia = false;
        %         Indicador_convergencia=2;
        %         this. indicador_convergencia0= Indicador_convergencia;
                this.Flag = 3;
                break;
            end

            if (ds_mw_total < this.MaxErrorMW) ... 
                && (discreto || isempty(this.TrafosReg)) ...
                && ~cambio_tipo_buses
                % hay convergencia
                if iter < this.NumIterSinCambioPVaPQ
                    obliga_verificacion_cambio_pv_pq = true;
                else
        %             convergencia = true;
                    this.Flag = 0;
                    break;
                end
            end

            if iter > this.MaxNumIter
                % se alcanzó el máximo número de iteraciones. No hay
                % convergencia
        %         convergencia = false;
        %         Indicador_convergencia=0;
        %         this. indicador_convergencia0= Indicador_convergencia;
                this.Flag = 2;
                break;
            end
        %------------------
            if (ds_mw_total < this.MaxErrorMW) && ~isempty(this.TrafosReg) && ~discreto
                % convergió pero aún no se han discretizado los
                % transformadores reguladores
                % Pasos:
                % 1. Discretizar los pasos de los transformadores
                %    reguladores
                % 2. Cambiar estado de variables de UE --> U
                discreto = true;
                for bus = 1:h
                    if this.Subestaciones.TipoVarControl(bus) == 1 % 'TapReg'
                        % entrega lista de transformadores que regulan
                        % tensión del bus
                        cantidad_trafos = this.entrega_cantidad_trafos_reguladores(this.pBuses(bus));
                        for ittraf = 1:cantidad_trafos
                            paso_actual = this.entrega_paso_trafo_regulador(this.pBuses(bus), ittraf, true);
                            this.inserta_paso_actual_trafo_regulador(round(paso_actual), this.pBuses(bus), ittraf, true);
                        end
                        if cantidad_trafos == 0
                            error = MException('calcula_flujo_potencia:calcula_flujo_potencia','Variable del bus es TapReg pero no hay transformadores reguladores');
                            throw(error)
                        end
                        %ajustar variables
                        this.Subestaciones.VarEstado(bus, 2) = this.entrega_trafo_regulador(this.pBuses(bus), 1, true).entrega_voltaje_objetivo_pu();
                        this.Subestaciones.TipoVarControl(bus) = 0; % 'V'
                        this.Subestaciones.TipoVarEstado(bus, 2) = 0; % 'V'
                    end
                end
            end

            % nueva iteración
            % actualiza J debido a los cambios del transformadores
            this.actualiza_matriz_jacobiana();

            if this.NivelDebug > 1
                prot = cProtocolo.getInstance;
                prot.imprime_matriz(this.J, ['Matriz Jacobiana sin eliminación en iteracion: ' num2str(iter)]);
            end

            %borrar filas y columnas de la barra slack
            % se borra el ángulo y el voltaje ya que son conocidos,
            % el voltaje, ya que es conocido.
            % El ángulo se mantiene ya que es desconocido
            % con Indexing
            indice_a_borrar = [ this.Subestaciones.TipoBuses == 3;...
                ((this.Subestaciones.TipoBuses ==2 & this.Subestaciones.TipoVarControl == 0)...
                | this.Subestaciones.TipoBuses == 3) ];

            if ~find(this.Subestaciones.TipoBuses == 3) % no slack_encontrada
               error = MException('calcula_flujo_potencia:callcula_flujo_potencia','No se encontró slack');
               throw(error)
            end
            % crea indices entre variables de estado y
            % las "nuevas" variables de estado, en donde se borraron
            % los valores conocidos
            IndiceVarSol = not(indice_a_borrar);
            delta_s_1 = [delta_s(:,1);delta_s(:,2)];
            VecSol = delta_s_1(IndiceVarSol);

            % borra filas y columnas de la matriz jacobiana
            this.J(:,indice_a_borrar) = [];
            this.J(indice_a_borrar,:) = [];

            % resuelve sistema de ecuaciones
            Sol = -this.J\VecSol;
            if this.NivelDebug > 1
                prot = cProtocolo.getInstance;
                prot.imprime_vector([this.Subestaciones.VarEstado(:,1);this.Subestaciones.VarEstado(:,2)], 'antiguo vector con variables de estado');
                prot.imprime_vector(indice_a_borrar, 'indices a borrar');
                prot.imprime_matriz(this.J, 'Matriz jacobiana sin filas ni columnas');
                prot.imprime_vector(VecSol, 'VecSol');
                prot.imprime_vector(IndiceVarSol, 'indice de variables y solucion');
                prot.imprime_vector(Sol, 'Sol');
            end

            % escribe resultados en VarEstado
            VarEstado1 = reshape(this.Subestaciones.VarEstado,[],1);
            VarEstado1(IndiceVarSol) = VarEstado1(IndiceVarSol) - Sol()...
                .*[ones(sum(IndiceVarSol(1:h)),1); this.Subestaciones.VarEstado(IndiceVarSol(h+1:end),2)];
            this.Subestaciones.VarEstado = reshape(VarEstado1, [], 2);

            if this.NivelDebug > 1
                prot = cProtocolo.getInstance;
                prot.imprime_vector([this.Subestaciones.VarEstado(:,1);this.Subestaciones.VarEstado(:,2)], 'nuevo vector solucion');
                imprime_estado_variables(this);
            end
        %---------------------
            % actualizar paso de los transformadores
            bus_TapReg = find(this.Subestaciones.TipoVarControl == 1); % 'TapReg'
            for bus_i = 1:length(bus_TapReg)
                bus = bus_TapReg(bus_i);
                cantidad_trafos = this.entrega_cantidad_trafos_reguladores(this.pBuses(bus));
                for itr = 1:cantidad_trafos
                    this.inserta_paso_actual_trafo_regulador(this.Subestaciones.VarEstado(bus, 2), this.pBuses(bus), itr, true);
                end
            end

            % actualizar matriz de admitancia debido a transformadores
            % reguladores
            this.actualiza_matriz_admitancia();

            iter = iter + 1;
        end
        % fin de las iteraciones. Se calculan y escriben los resultados del flujo de potencias 

        if this.NivelDebug > 1
            prot = cProtocolo.getInstance;
            text = ['Fin flujo de potencias. Estado flag: ' num2str(this.Flag) '\nImprime estado de variables\n'];
            prot.imprime_texto(text);
            imprime_estado_variables(this);
        end

        % Flujo de potencias convergente.
        this.calcula_y_escribe_resultados_fp(delta_s,nro_subsistema);
        if this.NivelDebug > 1
            cProtocolo.getInstance.imprime_texto(['Flag final del flujo de potencias: ' num2str(this.Flag)]);
           % this.guarda_solucion_formato_matpower();
        %-----------------
        % elseif this.NivelDebug == 1
        %     guarda_solucion_indices(this)

        end
        end

        function inicializa_variables_fp(this)
        % Generadores
        this.Generadores.ControlaTensionFP = this.Generadores.ControlaTension;
        this.Generadores.Pfp = this.Generadores.P0;
        this.Generadores.Qfp(this.Generadores.ControlaTensionFP) = 0;
        this.Generadores.Qfp(~this.Generadores.ControlaTensionFP) = ...
            this.Generadores.Q0(~this.Generadores.ControlaTensionFP);

        % Consumo  
        this.Consumos.Qfp = this.Consumos.Q0;
        this.Consumos.Pfp = this.Consumos.P0;
        this.Consumos.Qfp(this.Consumos.DepVoltaje) = 0;
        this.Consumos.Pfp(this.Consumos.DepVoltaje) = 0;
        end

        function construye_matriz_admitancia(this)
            this.Adm = zeros(this.num.Subestaciones);
            % Lineas
            if isprop(this,'Lineas')
                [y11, y12, y21, y22] = entrega_cuadripolo_linea(this);
                n = this.Subestaciones.Id(this.Lineas.Bus1);
                m = this.Subestaciones.Id(this.Lineas.Bus2);
                % signos están considerados en cálculo de cuadripolos. Aquí
                % sólo hay que ingresar los datos
                idx = sub2ind(size(this.Adm), n, m);
                [a,~,c] = unique(idx);
                y = accumarray(c,y12);
                this.Adm(a) = this.Adm(a) + y;

                idx = sub2ind(size(this.Adm), m, n);
                [a,~,c] = unique(idx);
                y = accumarray(c,y21);
                this.Adm(a) = this.Adm(a) + y;

                idx = sub2ind(size(this.Adm), n, n);
                [a,~,c] = unique(idx);
                y = accumarray(c,y11);
                this.Adm(a) = this.Adm(a) + y;

                idx = sub2ind(size(this.Adm), m, m);
                [a,~,c] = unique(idx);
                y = accumarray(c,y22);
                this.Adm(a) = this.Adm(a) + y;
            end
            % Trafos
            if isprop(this,'Trafos')
                [y11, y12, y21, y22] = entrega_cuadripolo_trafo(this);
                n = this.Subestaciones.Id(this.Trafos.Bus1);
                m = this.Subestaciones.Id(this.Trafos.Bus2);
                % signos están considerados en cálculo de cuadripolos. Aquí
                % sólo hay que ingresar los datos
                idx = sub2ind(size(this.Adm), n, m);
                [a,~,c] = unique(idx);
                y = accumarray(c,y12);
                this.Adm(a) = this.Adm(a) + y;

                idx = sub2ind(size(this.Adm), m, n);
                [a,~,c] = unique(idx);
                y = accumarray(c,y21);
                this.Adm(a) = this.Adm(a) + y;

                idx = sub2ind(size(this.Adm), n, n);
                [a,~,c] = unique(idx);
                y = accumarray(c,y11);
                this.Adm(a) = this.Adm(a) + y;

                idx = sub2ind(size(this.Adm), m, m);
                [a,~,c] = unique(idx);
                y = accumarray(c,y22);
                this.Adm(a) = this.Adm(a) + y;
            end
            % 2. Elementos paralelos (Condensador, Consumo, Reactor,(Generador))
            % Consumo
            if isprop(this,'Consumos')
                if this.Consumos.DepVoltaje ~= 0
                    cons = this.Consumos.DepVoltaje ~= 0;
                    ns = this.Subestaciones.Id(this.Consumos.Bus(cons));
                    vnom = this.Subestaciones.Vn(this.Consumos.Bus(cons));
                    ynn = complex(this.Consumos.P0(cons)./(vnom.^2),this.Consumos(cons).Q0./(vnom.^2));

                    idx = sub2ind(size(this.Adm), ns, ns);
                    [a,~,c] = unique(idx);
                    y = accumarray(c,ynn);
                    this.Adm(a) = this.Adm(a) + y;
                end
            end
            % Condensador
            if isprop(this,'Condensadores')
                ns = this.Subestaciones.Id(this.Condensadores.Bus);
                ynn = -complex(0,this.Condensadores.Qr./this.Condensadores.Vr .^2);
                ynn = ynn.*this.Condensadores.TapActual./this.Condensadores.TapMax;
                idx = sub2ind(size(this.Adm), ns, ns);
                [a,~,c] = unique(idx);
                y = accumarray(c,ynn);
                this.Adm(a) = this.Adm(a) + y;
            end
            % Reactores
            if isprop(this,'Reactores')
                ns = this.Subestaciones.Id(this.Condensadores.Bus);
                vbase = this.Subestaciones.Vn(this.Condensadores.Bus);
                ybase = this.sbase./vbase.^2;
                ynn = -complex(0,this.Condensadores.Qr./this.Condensadores.Vr .^2);
                ynn = ynn.*this.Condensadores.TapActual./this.Condensadores.TapMax;
                ynn = ynn./ybase;
                idx = sub2ind(size(this.Adm), ns, ns);
                [a,~,c] = unique(idx);
                y = accumarray(c,ynn);
                this.Adm(a) = this.Adm(a) + y;
            end
            if this.NivelDebug > 1
                prot = cProtocolo.getInstance;
                prot.imprime_matriz(this.Adm, 'Matriz Admitancia');
            end
            this.Adm_init = this.Adm;
        end

        function [y11, y12, y21, y22] = entrega_cuadripolo_linea(this)
            % Siempre en pu.
            if this.Lineas.Largo == 0
                error = MException('cLinea:entrega_cuadripolo','largo de la línea no definido');
                throw(error)
            end
            vbase = this.Subestaciones.Vn(this.Lineas.Bus1);
            zbase = vbase.^2./this.sbase;
            x = this.Lineas.Largo .* this.Lineas.Xpul;
            if sum(this.Lineas.PorcentajeCompensacion ~= 0)> 0
                x = x.*(ones(size(this.Lineas.PorcentajeCompensacion))-this.Lineas.PorcentajeCompensacion);
            end
            r = this.Lineas.Largo .* this.Lineas.Rpul;
            b = this.Lineas.Largo .* this.Lineas.Cpul * 2 *pi *50 / 1000000;
            g = this.Lineas.Largo .* this.Lineas.Gpul;
            yserie = 1./complex(r,x);
            y0 = complex(0.5*g,0.5*b);

            y12 = -yserie.*zbase;
            y21 = -yserie.*zbase;
            y11 = (y0 + yserie).*zbase;
            y22 = (y0 + yserie).*zbase;
        end

        function [y11, y12, y21, y22] = entrega_cuadripolo_trafo(this, varargin)
            % varargin entrega el valor del tap regulador, en caso de que se indique
            if nargin > 1
                valor_tap_regulador = varargin{1};
                this.Trafos.TapActual(this.Trafos.IdTapRegulador) = valor_tap_regulador;
            end

            vbase = this.Subestaciones.Vn(this.Trafos.Bus1);
            zbase = vbase.^2./this.sbase;

            % primero valores base convertidos a pu y luego consideran los
            % taps
            r = this.Trafos.Pcu.*(this.Trafos.Vr1./this.Trafos.Sr).^2./zbase;
            x = this.Trafos.Uk .*((this.Trafos.Vr1.^2)./this.Trafos.Sr)./zbase;
            zk = complex(r, x);

            g = this.Trafos.P0 ./ this.Trafos.Vr1.^2 ./ 1000 .* zbase;
            b = sqrt(3)* this.Trafos.I0 ./ this.Trafos.Vr1 .* zbase;
            y0 = complex(0.5*g,0.5*b);

            y11 =  (1./zk + y0);
            y12 =  -1./zk;
            y21 =  -1./zk;
            y22 =  (1./zk + y0);

        %     if this.Trafos.CantidadTaps == 0
        %         y11 =  (1./zk + y0);
        %         y12 =  -1./zk;
        %         y21 =  -1./zk;
        %         y22 =  (1./zk + y0);
        %     else
        %         % calcula diferencia de voltaje en el primario (dup) y
        %         % secundario (dus). Para ello, se calcula la diferencia de voltaje de cada uno de los taps y luego se asignan al lado correspondiente
        % 
        %         du_taps = (tap_actual - this.TapNom).*this.DuTap;
        %         angulo_taps = zeros(this.CantidadTaps,1);
        %         for i = 1:this.CantidadTaps
        %             if this.LadoTap(i) == 2
        %                 angulo_taps(i) = angle(this.RelTrans);
        %             end
        %         end
        %         du_taps = du_taps.*complex(cos(angulo_taps), sin(angulo_taps));
        % 
        %         % calcula diferencia de voltaje en el primario y secundario
        %         du_p = sum(du_taps(this.LadoTap == 1));
        %         du_s = sum(du_taps(this.LadoTap == 2));
        % 
        %         tp = (1+du_p)/abs(1+du_p)^2;
        %         ts = (1+du_s)/abs(1+du_s)^2;
        % 
        %         y11 =  (1/zk + y0)*abs(tp)^2;
        %         y12 =  -1/zk*conj(tp)*ts;
        %         y21 =  -1/zk*tp*conj(ts);
        %         y22 =  (1/zk + y0)/abs(ts)^2;
        %     end
        end

        function inicializa_variables(this)
            if this.NivelDebug > 1
                prot = cProtocolo.getInstance;
                prot.imprime_texto('Inicializa variables');
            end
        % se identifican barras PV, PQ, Slack
        % Tipobuses: Se actualiza en cada iteración, indica si es   
        %            Passivo = 0, PQ = 1, PV = 2 o Slack = 3.
        % VarEstado: Variables de estado tienene el formato Ángulos (para todos los
        %            buses) y después los voltajes
        % TipoVarControl: Tipo de variable de control del bus. Puede ser  
        %            'V' = 0 o 'TapReg' = 1 (para los transformadores reguladores)
        % Snom: contiene las potencias reales P (para todos los buses) y 
        %            luego las potencias aparentes Q

            h = this.num.Subestaciones;
            Buses = this.Subestaciones;
            Buses.VarEstado = zeros(h,2);
            Buses.Snom = zeros(h,2);
            Buses.TipoBuses = zeros(h,1);
            Buses.TipoVarControl = zeros(h,1); %valor por defecto: 'V'
            Buses.VoltajeObjetivo = zeros(h,1);

            CT = this.Generadores.Bus(this.Generadores.ControlaTension == 1);
            if ~isempty(CT)
                PQ = [this.Generadores.Bus(this.Generadores.ControlaTension == 0);this.Consumos.Bus(:)];
                Buses.TipoBuses(PQ) = 1;% PQ
                Gen_Slack = this.Generadores.Bus(this.Generadores.ControlaTension == 1 & this.Generadores.Slack == 1);
                Gen_noSlack = this.Generadores.Bus(this.Generadores.ControlaTension == 1 & this.Generadores.Slack == 0);
                Buses.TipoBuses(Gen_Slack) = 3;% Slack
                Buses.TipoBuses(Gen_noSlack) = 2;% PV
                Buses.VoltajeObjetivo(CT) = this.Generadores.VoltajeObjetivo(this.Generadores.ControlaTension == 1)./Buses.Vn(CT);

            end

            %Condensador, Reactor???
            %Consumo
            Cons = this.Consumos.Bus(this.Consumos.DepVoltaje == 0);
            if ~isempty(Cons)
                Buses.Snom(Cons,:) = [-this.Consumos.P0([Buses.Consumos{Cons}])/this.sbase, -this.Consumos.Q0([Buses.Consumos{Cons}])/this.sbase];
            end
            Cons = this.Consumos.Bus(this.Consumos.DepVoltaje == 1);
            if ~isempty(Cons)
                Buses.Snom(Cons,:) = [0,0];
            end

            %Generador
            unico = unique(this.Generadores.Bus);
            Pfp = cellfun(@(s) sum(this.Generadores.Pfp(s)), this.Subestaciones.Generadores(unico));
            Buses.Snom(unico) = Buses.Snom(unico) + Pfp/this.sbase;

            %Transformador
            Lados = this.Trafos.LadoTap(this.Trafos.ControlaTension == 1);
            if ~isempty(Lados)
                buses = [this.Trafos.Bus1(Lados == 1);this.Trafos.Bus2(Lados == 2)];
                members = ismember(buses, this.BusesConRegPorTrafo);
                this.BusesConRegPorTrafo = [this.BusesConRegPorTrafo buses(~members)];
                this.TrafosReg = [this.TrafosReg; this.Trafos.Id(this.Trafos.ControlaTension == 1)];
                Buses.TipoVarControl(buses(~members)) = 1; % 'TapReg'
                this.Trafos.ControlaTensionFP(buses(~members)) = true;
                % ya existe un transformador regulador
                % para este bus. Hay que verificar que
                % sean paralelos
                if ~ismember(this.Trafos.Id(this.Trafos.ControlaTension == 1),this.TrafosReg)
                    error = MException('calcula_flujo_potencia:inicializa_tipo_variables_decision','existen dos transformadores que regulan el mismo nodo pero no son paralelos');
                    throw(error)
                end
            end

            if this.NivelDebug > 1
                prot = cProtocolo.getInstance;
                prot.imprime_vector([Buses.Snom(:,1); Buses.Snom(:,2)], 'Snom');
            end
            this.Subestaciones = Buses;
        end

        function determina_condiciones_iniciales(this)
            % determina voltajes y ángulos de inicio
            % eventualmente falta agregar un mejor método
            % Por ahora, todos los voltajes en las barras PQ = valor nominal
            % y para las barras PV = valor voltaje objetivo

            this.Subestaciones.VarEstado(:) = 0;
            bus_PV_Slack = find(this.Subestaciones.TipoBuses > 1); % PV = 2, Slack = 3
            if ~isempty(bus_PV_Slack)
                this.Subestaciones.VarEstado(bus_PV_Slack,2) = ones(size(bus_PV_Slack))...
                    *this.Subestaciones.VoltajeObjetivo(bus_PV_Slack(1));
            end
            this.Subestaciones.VarEstado( this.Subestaciones.TipoBuses < 2,2) = 1.02; % PQ = 1, Pasivo = 0

            % asumiendo que son pocos los transformadores reguladores, es
            % más eficiente reemplazar valor original. Como en este caso se
            % están determinando las condiciones iniciales, no es necesario
            % verificar si el bus es PQ o PV
            if ~isempty(this.BusesConRegPorTrafo)
                tap_actual = this.Trafos.TapActual(this.Trafos.IdTapRegulador);
                tap_nom = this.Trafos.TapNom(this.Trafos.IdTapRegulador);
                du_tap = this.Trafos.DuTap(this.Trafos.IdTapRegulador);
                this.Subestaciones.VarEstado(this.BusesConRegPorTrafo, 2) = 1 + (tap_actual - tap_nom)*du_tap;
                this.Subestaciones.TipoBuses(this.BusesConRegPorTrafo) = 2; % 'PV'
            end
        end

        function s_complejo = calcula_s_complejo(this)
            %entrega la potencia como resultado del sistema de ecuaciones
            Buses = this.Subestaciones;
            u = zeros(this.num.Subestaciones,1);
            u(Buses.TipoVarControl==0) = Buses.VarEstado(Buses.TipoVarControl==0,2);
            TapReg = Buses.TipoVarControl==1;
            if sum(TapReg)~= 0
                if ~ismember([this.Subestaciones.Trafos{[4,5]}], this.TrafosReg)
                    error = MException('calcula_flujo_potencia:calcula_s_complejo','no se pudo encontrar trafo regulador y flag es obligatorio');
                    throw(error)
                end
                u(TapReg) = this.Trafos.VoltajeObjetivo(this.Subestaciones.Trafos(TapReg))./this.Subestaciones.Vn(TapReg);
            end
            theta = Buses.VarEstado(:,1);
            u_bus = (cos(theta)+ 1i*sin(theta)) .* u;

            s_complejo = diag(u_bus)*conj(this.Adm*u_bus);
            if this.NivelDebug > 1
                prot = cProtocolo.getInstance;
                prot.imprime_matriz(u_bus, 'u_bus');
                prot.imprime_vector(s_complejo, 's_complejo');
            end
        end

        function actualiza_matriz_jacobiana(this)
            h = this.num.Subestaciones;
            this.J = zeros(2*h);
            f = false(h);
            dpi_dui = zeros(h,1);
            dqi_dui = zeros(h,1);
            u = zeros(h,1);

            VarControl = this.Subestaciones.TipoVarControl == 1;
            u(~VarControl) = this.Subestaciones.VarEstado(~VarControl,2);
            for ff = 1: sum(VarControl)
                % transformador regulador
                fila = find(this.Subestaciones.TipoVarControl == 1);
                trafos = [this.Subestaciones.Trafos{fila(ff)}];
                indice = ismember(trafos, this.TrafosReg);
                if ~isempty(indice)
                    if this.Trafos.ControlaTension(trafos(indice))
                        u = this.Trafos.VoltajeObjetivo(trafos(indice))/this.Subestaciones.Vn(fila(ff));
                    else
                        error = MException('cTransformador2D:entrega_voltaje_objetivo','transformador no controla tension');
                        throw(error)
                    end
                else
                    error = MException('calcula_flujo_potencia:callcula_flujo_potencia','Variable del bus es TapReg pero no hay transformadores reguladores');
                    throw(error)
                end
            end
            t = this.Subestaciones.VarEstado(:,1);
            mat = this.Adm ~=0;
            % derivadas c/r al voltaje para buses no regulados por transformadores reguladores
            % En caso de que el bus sea regulado por un transformador, los valores
            % se agregan después a partir de los elementos fuera de la diagonal
            vars_ii = diag(this.Adm);
            ind_diag = find(vars_ii ~= 0);
            if sum(VarControl) > 0
                ind_diag = intersect(ind_diag, find(~VarControl));
            end

            yrii = real(vars_ii);
            yiii = imag(vars_ii);
            dpi_dui(ind_diag) = dpi_dui(ind_diag) + 2.*u(ind_diag).^2.*yrii;
            dqi_dui(ind_diag) = dqi_dui(ind_diag) - 2.*u(ind_diag).^2.*yiii;

            %fuera de la diagonal
            mat_ij = logical(logical(mat)-eye(h));
            vars_ij = this.Adm(mat_ij);
            [filas, cols] = find(mat_ij == 1);

            l = length(filas);
            dpi_duj = zeros(l,1);
            dqi_duj = zeros(l,1);

            sinij = sin(t(filas)-t(cols));
            cosij = cos(t(filas)-t(cols));

            yrij = real(vars_ij);
            yiij = imag(vars_ij);

            % derivadas con respecto a theta. No hay distinción
            % entre si el bus está regulado por un trafo
            dpi_dtj = u(filas).*u(cols).*(yrij.*sinij-yiij.*cosij);
            dqi_dtj = -u(filas).*u(cols).*(yrij.*cosij+yiij.*sinij);

            this.J([mat_ij, f; f, f]) = dpi_dtj; % fila,col
            this.J([f, f; mat_ij, f]) = dqi_dtj; %fila + h ,col

            % agrega elementos para la diagonal para las
            % derivadas con respecto a theta
            [~,~,c] = unique(filas);
            dpi_dti = accumarray(c,-dpi_dtj);%dpi_dti(filas) - dpi_dtj;
            dqi_dti = accumarray(c,-dqi_dtj);%dqi_dti(filas) - dqi_dtj;

            % derivadas con respecto a u o a t. En este caso hay que
            % hacer una distinción entre buses regulados por
            % transformadores y los que no

            % agrega elemento para la diagonal en caso de que
            % el bus col no sea regulado por un transformador
            % regulador
            noControl = this.Subestaciones.TipoVarControl(filas) == 0; % 'V'
            filas_noControl = filas(noControl);
            [~,~,c] = unique(filas_noControl);
            dpi_dui_ges = u(filas_noControl).*u(cols(noControl)).*...
                (yrij(noControl).*cosij(noControl)+yiij(noControl).*sinij(noControl));
            dpi_dui = dpi_dui + accumarray(c,dpi_dui_ges);

            dqi_dui_ges =  u(filas_noControl).*u(cols(noControl)).*...
                (yrij(noControl).*sinij(noControl)-yiij(noControl).*cosij(noControl));
            dqi_dui = dqi_dui + accumarray(c,dqi_dui_ges);

            noControl = this.Subestaciones.TipoVarControl(cols) == 0; % 'V'
            dpi_duj(noControl) = u(filas(noControl)).*u(cols(noControl)).*...
                (yrij(noControl).*cosij(noControl)+yiij(noControl).*sinij(noControl));
            dqi_duj(noControl) = u(filas(noControl)).*u(cols(noControl)).*...
                (yrij(noControl).*sinij(noControl)-yiij(noControl).*cosij(noControl));

            this.J([f, mat_ij; f, f]) = dpi_duj; % fila,col+ h
            this.J([f, f; f, mat_ij]) = dqi_duj; % fila + h ,col+ h

            d = eye(h, 'logical');
            % dP
            this.J([d, f; f, f]) = dpi_dti; % fila, fila
            this.J([f, d; f, f]) = dpi_dui; % fila, fila + h
            % dQ
            this.J([f, f; d, f]) = dqi_dti; % fila + h, fila
            this.J([f, f; f, d]) = dqi_dui; % fila + h, fila + h
        end

        function imprime_estado_variables(this)
            % varargin indica si ángulos se imprimen en radianes o grados
            if this.NivelDebug > 0    
                prot = cProtocolo.getInstance;
                prot.imprime_texto('variables y estados');

                prot.imprime_texto('Tipo buses entrada');
                texto = sprintf('%10s %10s', 'Bus', 'Tipo bus');
                prot.imprime_texto(texto);
            end
            h = this.num.Subestaciones;
            for bus = 1:h
                texto = sprintf('%10s %10s %10s', num2str(bus), num2str(this.Subestaciones.TipoBuses(bus)));
                prot.imprime_texto(texto);
            end

            prot.imprime_texto('Valores vector de estados');
            texto = sprintf('%10s %10s %10s %10s', 'Nr.Var', 'Bus', 'Tipo', 'Valor');
            prot.imprime_texto(texto);
            for bus = 1:h
                % primero angulos
                texto = sprintf('%10s %10s %10s %10s %10s', num2str(bus), num2str(bus),...
                    'Theta', num2str(this.Subestaciones.VarEstado(bus,1)),...
                    '(', num2str(this.Subestaciones.VarEstado(bus,1)/pi*180), ' grados)');
                prot.imprime_texto(texto);
            end
            for bus = 1:h
                % voltajes o tap de transformadores
                texto = sprintf('%10s %10s %10s', num2str(bus + h), num2str(bus),...
                    num2str(this.Subestaciones.TipoVarControl(bus)), num2str(this.Subestaciones.VarEstado(bus,2)));
                prot.imprime_texto(texto);
            end

            prot.imprime_texto('Snom:');
            texto = sprintf('%10s %10s %10s %10s', 'Nr.Var', 'Bus', 'Tipo', 'Valor');
            prot.imprime_texto(texto);
            for bus = 1:h
                % primero Pnom
                texto = sprintf('%10s %10s %10s %10s', num2str(bus), num2str(bus), 'MW', num2str(this.Subestaciones.Snom(bus,1)));
                prot.imprime_texto(texto);
            end
            for bus = 1:h
                % Qnom
                texto = sprintf('%10s %10s %10s %10s', num2str(bus + h), num2str(bus), 'MVA', num2str(this.Subestaciones.Snom(bus,2)));
                prot.imprime_texto(texto);
            end
        end

        function actualiza_matriz_admitancia(this)
            % hay que actualizar datos debido a los transformadores reguladores
            for i = 1:length(this.BusesConRegPorTrafo)
                for j = 1:length(this.TrafosReg(i).Lista)
                    eserie = this.TrafosReg(i).Lista(j);
                    n = this.TrafosReg(i).IDBusReg(j);  % en teoría redundante, ya que los buses son los mismos para todos los transformadores
                    m = this.TrafosReg(i).IDBusNoReg(j);
                    tap_antiguo = this.TrafosReg(i).PasoActualAdm(j);
                    tap_nuevo = eserie.entrega_elemento_red().entrega_tap_actual_regulador();
                    if tap_antiguo ~= tap_nuevo
                        %actualiza matriz admitancia
                        [y11, y12, y21, y22] = eserie.entrega_elemento_red().entrega_cuadripolo(tap_antiguo);

                        this.Adm(n,m) = this.Adm(n,m) - y12;
                        this.Adm(m,n) = this.Adm(m,n) - y21;
                        this.Adm(n,n) = this.Adm(n,n) - y11;
                        this.Adm(m,m) = this.Adm(m,m) - y22;

                        [y11, y12, y21, y22] = eserie.entrega_cuadripolo();
                        this.Adm(n,m) = this.Adm(n,m) + y12;
                        this.Adm(m,n) = this.Adm(m,n) + y21;
                        this.Adm(n,n) = this.Adm(n,n) + y11;
                        this.Adm(m,m) = this.Adm(m,m) + y22;
                        this.TrafosReg(i).PasoActualAdm(j) = tap_nuevo;
                    end
                end
            end
        end

        function calcula_y_escribe_resultados_fp(this, delta_s, nro_subsistema)
            % @Lena: Die Ergebnisse sollen in ResultadoFlujoPotencia (der
            % Klasse cResultadoEvaluacionSEP) geschrieben werden. Nicht
            % mehr im pSEP. Bitte denke daran, dass du diese Klasse
            % "freiwillig" benutzen kannst, wie ich es am Anfang dieser
            % Klasse geschrieben habe. Einfach die Containers besetzen, die
            % du brauchst. Bitte gibt auch die Möglichkeit, "nicht
            % detailiertere Ergebnisse zu speichern" (genauso wie beim
            % DCOPF. In diesem Fall soll so wenige Daten wie Möglich
            % gespeichert werden. Z.B. nur die Schaltanlage ID, wo die
            % Spannung sich ausserhalb der Grenze befindet, die
            % Leitungen/Transformatoren, wo auch der maximalen Fluss
            % überschritten wurde, etc. 
            
            % escribe resultados del flujo de potencias para subsistema actual
            if this.Flag > 1
                %Flujo de potencias no convergente. Se eliminan los
                %resultados en los elementos de red (falta hacer)
                return
            end

            s_complejo = calcula_s_complejo(this);
            delta_s = complex(this.Subestaciones.Snom(:,1), this.Subestaciones.Snom(:,2))- s_complejo;
        %     if this.NivelDebug > 1
        %         prot = cProtocolo.getInstance;
        %         prot.imprime_vector(delta_s, 'delta_s_fin');
        %     end           
            % ingresa valores para cálculo de resultado
            P0 = this.Generadores.P0(this.Generadores.Slack);
            bus_con_gen_slack = this.Subestaciones.Id(this.Generadores.Bus(this.Generadores.Slack));
            P = P0/this.sbase - real(delta_s(bus_con_gen_slack));
            this.Generadores.Pfp(this.Generadores.Slack) = P*this.sbase;
            err = sum(abs(real(delta_s(this.Subestaciones.Id(this.Generadores.Slack == 0)))) > 0.001);
            if  err > 0
                error = MException('calcula_flujo_potencia:calcula_y_escribe_resultados_fp','%d bus(es) no es slack pero existe p residual significativo', err);
                throw(error)
            end
            for i = 1:length(delta_s)
                estado = this.distribuye_q_residual(i, -imag(delta_s(i)));
            end

            % Se ingresan resultados para consumos con dependencia de voltaje
            % Condensador & Reactor
        %     if isa(el_red, 'cCondensador') || isa(el_red, 'cReactor')
        %         y0 = el_red.entrega_dipolo_pu();
        %         pres = real(y0)*vbus^2;
        %         qres = -imag(y0)*vbus^2;
        %         el_red.inserta_resultados_flujo_potencia(this.id_fp, pres, qres);

            if isprop(this, 'Consumos') && ~isempty(this.Consumos.DepVoltaje == 1)
                cons = this.Consumos.Bus(this.Consumos.DepVoltaje == 1);
                vbus = this.Subestaciones.Vn(cons);
                vnom =this.Subestaciones.VarEstado(cons,2).*vbus;
                p0 = this.Consumos.P0(this.Consumos.DepVoltaje == 1);
                q0 = -this.Consumos.Q0(this.Consumos.DepVoltaje == 1);
                P = p0.*vbus.^2./vnom.^2;
                Q = q0.*vbus.^2./vnom.^2;
                this.Consumos.Pfp(this.Consumos.DepVoltaje == 1) = P*this.sbase;
                this.Consumos.Qfp(this.Consumos.DepVoltaje == 1) = Q*this.sbase;
            end

            if estado > 0
                % hay violación de los límites de los generadores. Se
                % actualiza el Flag
                this.Flag = 1;
            end

            % Flujos de los elementos en serie (Lineas, Trafos)
            % Lineas
            v1 = this.Subestaciones.VarEstado(this.Lineas.Bus1,2).*complex(...
                cos(this.Subestaciones.VarEstado(this.Lineas.Bus1,1)),...
                sin(this.Subestaciones.VarEstado(this.Lineas.Bus1,1)));
            v2 = this.Subestaciones.VarEstado(this.Lineas.Bus2,2).*complex(...
                cos(this.Subestaciones.VarEstado(this.Lineas.Bus2,1)),...
                sin(this.Subestaciones.VarEstado(this.Lineas.Bus2,1)));
            [y11, y12, y21, y22] = entrega_cuadripolo_linea(this);

            i1 = (v1.*y11+v2.*y12);
            i2 = (v1.*y21+v2.*y22);
            s1 = v1.*conj(i1);
            s2 = v2.*conj(i2);
            perdidas = s1+s2;

            % conversión a unidades de salida
            i1_angulo = angle(i1);
            i2_angulo = angle(i2);

            ibase = this.sbase./v1;
            this.Lineas.I1 = i1.*ibase/sqrt(3);
            this.Lineas.I2 = i2.*ibase/sqrt(3);
            this.Lineas.ThetaI1 = i1_angulo/pi*180;
            this.Lineas.ThetaI2 = i2_angulo/pi*180;
            this.Lineas.S1 = s1*this.sbase;
            this.Lineas.S2 = s2*this.sbase;
            this.Lineas.Perdidas = perdidas*this.sbase;

            this.Perdidas = this.Perdidas + sum(this.Lineas.Perdidas(this.Lineas.EnServicio));

            % Trafos
            v1 = this.Subestaciones.VarEstado(this.Trafos.Bus1,2).*complex(...
                cos(this.Subestaciones.VarEstado(this.Trafos.Bus1,1)),...
                sin(this.Subestaciones.VarEstado(this.Trafos.Bus1,1)));
            v2 = this.Subestaciones.VarEstado(this.Trafos.Bus2,2).*complex(...
                cos(this.Subestaciones.VarEstado(this.Trafos.Bus2,1)),...
                sin(this.Subestaciones.VarEstado(this.Trafos.Bus2,1)));
            [y11, y12, y21, y22] = entrega_cuadripolo_trafo(this);

            i1 = (v1.*y11+v2.*y12);
            i2 = (v1.*y21+v2.*y22);
            s1 = v1.*conj(i1);
            s2 = v2.*conj(i2);
            perdidas = s1+s2;

            % conversión a unidades de salida
            i1_angulo = angle(i1);
            i2_angulo = angle(i2);

            ibase = this.sbase./v1;
            this.Trafos.I1 = i1.*ibase/sqrt(3);
            this.Trafos.I2 = i2.*ibase/sqrt(3);
            this.Trafos.ThetaI1 = i1_angulo/pi*180;
            this.Trafos.ThetaI2 = i2_angulo/pi*180;
            this.Trafos.S1 = s1*this.sbase;
            this.Trafos.S2 = s2*this.sbase;
            this.Trafos.Perdidas = perdidas*this.sbase;

            this.Perdidas = this.Perdidas + sum(this.Trafos.Perdidas(this.Trafos.EnServicio));
        end

        function [estado] = distribuye_q_residual(this, bus_id, q_residual)
            % estado = 0 si todo está en orden
            % estado = 1 si se violan los límites de potencia reactiva de
            % los generadores
            estado = 0;
            if abs(q_residual) < 0.01
                % error es muy chico. No se hace nada para evitar errores
                % numéricos
                return
            end
            % q residual se prorratea en base a Qmax de las unidades de
            % generación
            qlim_elemento = [];
            gens_de_bus = [this.Subestaciones.Generadores{bus_id}]';
            if isempty(gens_de_bus)
                return
            end
            gen_slack = gens_de_bus(this.Generadores.Slack(gens_de_bus)== 1);
            gens = this.Generadores.ControlaTensionFP(gens_de_bus)== 1;
            indices = gens_de_bus(gens);
            this.Generadores.Qfp(indices) = 0;
            if q_residual > 0
                qlim_elemento = this.Generadores.Qmax(indices)./this.sbase;
            else
                qlim_elemento = this.Generadores.Qmin(indices)./this.sbase;
            end

            if isempty(gen_slack) && (abs(sum(qlim_elemento)) < abs(q_residual))
                if this.NivelDebug > 0
                    texto = ['q residual (' num2str(q_residual) ') en bus ' num2str(bus_id)...
                        ' es mayor al límite de potencia reactiva de los generadores que controlan voltaje'];
                    warning(texto);
                end
                estado = 1;
                % como hay violación de los límites, valor residual se guarda en generador con indice_max
                [~, indice] = max(qlim_elemento);
                indice_max = indices(indice);
            end

            iter = 0;
            while true
                iter = iter + 1;
                % prorratea q_residual dependiendo de qmax
                suma_qlim = sum(qlim_elemento);
                q_nom = q_residual*qlim_elemento/suma_qlim;
                indices_a_eliminar = [];
                for i = 1:length(indices)
                    if abs(q_nom(i)) < abs(qlim_elemento(i))
                        this.Generadores.Qfp(indices(i))= q_nom(i)*this.sbase;
                        q_residual = q_residual - q_nom(i);
                        qlim_elemento(i) = qlim_elemento(i)-q_nom(i);
                    else
                        % fija al límite
                        this.Generadores.Qfp(indices(i)) = qlim_elemento(i)* this.sbase;
                        q_residual = q_residual - qlim_elemento(i);
                        indices_a_eliminar = [indices_a_eliminar i];
                    end
                end

                if abs(q_residual) > 0.01
                    indices(indices_a_eliminar) = [];
                    qlim_elemento(indices_a_eliminar) = [];
                else
                    return;
                end

                if isempty(indices)
                    % no hay más índices. Significa que queda sólo el
                    % generador slack, o el estado es 1
                    if ~isempty(gen_slack)
                        qact = this.Generadores.Qfp(gen_slack)/this.sbase;
                        qact = qact + q_residual;
                        this.Generadores.Qfp(gen_slack) = qact*this.sbase;
                        return;
                    else
                        % distribuye lo restante en el generador de
                        % indice_max
                        qact = this.Generadores.Qfp(indice_max)/this.sbase;
                        qact = qact + q_residual;
                        this.Generadores.Qfp(indice_max) = qact*this.sbase;
                        return;
                    end
                end

                if iter > 10 
                    texto = ['error de programación. Iteración es mayor a 10. Q residual es aún: ' num2str(q_residual)];
                    error = MException('calcula_flujo_potencia:distribuye_q_residual',texto);
                    throw(error)
                end
            end
        end
        
        function [] = calcula_flujo_n_menos_1( this, po, nombre_doc)
            %prueba_n_menos_1: prueba el criterio N-1 por la hora actual
            %   calculas la fujo potencia por cada situacion en que un elemento (Linea o
            %   Transformador) de la lista no es en servicio y guardas los resultos en
            %   resultos_criterio.dat.
            %   Si el sistema todavia es convergente sin el elemento en servicio los
            %   resultados de la flujo potencia se quardan como en fp.dat. Si no se 
            %   quardan el Flag
            this.ListaLineas = this.Lineas.Id((abs(this.Lineas.S1)> this.Lineas.Sr*this.PorcCargaCriterioN1)&...
                (abs(this.Lineas.S2)> this.Lineas.Sr*this.PorcCargaCriterioN1));
            this.ListaTrafos = this.Trafos.Id((abs(this.Trafos.S1)> this.Trafos.Sr*this.PorcCargaCriterioN1)&...
                (abs(this.Trafos.S2)> this.Trafos.Sr*this.PorcCargaCriterioN1));
            
            this.FlagN1 = 1;
%             --- Optimacion general
%             this.Generadores.Q0(this.Generadores.Slack == 0) = this.Generadores.Qfp(this.Generadores.Slack == 0);
%             this.Generadores.P0(this.Generadores.Slack == 1) = this.Generadores.Pfp(this.Generadores.Slack == 1);
            % Lineas
            for i = 1:numel(this.ListaLineas)
                this.Perdidas = complex(0,0);
                % actualiz matriz Adm
                this.Adm = this.Adm_init;
                [y11, y12, y21, y22] = entrega_cuadripolo_linea(this);
                this.Subestaciones = this.Subestaciones_init;
                n = this.Subestaciones.Id(this.Lineas.Bus1(this.ListaLineas(i)));
                m = this.Subestaciones.Id(this.Lineas.Bus2(this.ListaLineas(i)));
                this.Adm(n,m) = this.Adm(n,m) - y12(this.ListaLineas(i));
                this.Adm(m,n) = this.Adm(m,n) - y21(this.ListaLineas(i));
                this.Adm(n,n) = this.Adm(n,n) - y11(this.ListaLineas(i));
                this.Adm(m,m) = this.Adm(m,m) - y22(this.ListaLineas(i));
                
                supr = struct();
                fields = fieldnames(this.Lineas);
                for f = 1:numel(fields)
                    supr.(fields{f}) = [];
                    supr.(fields{f}) = this.Lineas.(fields{f})(this.ListaLineas(i));
                    this.Lineas.(fields{f})(this.ListaLineas(i)) = [];
                end
                this.num.Lineas = numel(this.Lineas.Id);
                this.Lineas.Id = (1:this.num.Lineas)';
                this.Subestaciones.Lineas = cell(this.num.Subestaciones);
                for f = 1:this.num.Subestaciones
                    this.Subestaciones.Lineas(f) = {[this.Lineas.Id(this.Lineas.Bus1 == f)',...
                                                     this.Lineas.Id(this.Lineas.Bus2 == f)']};
                end
                
                [~] = calcula_flujo_potencia(this,po);
                if this.Flag > 1
                    docID = fopen(nombre_doc, 'a+');
                    texto = sprintf('Resultado flujo de potencias para hora %d ,Linea %d\nNo functiona porque Flag = %d\n',...
                        po, supr.Id_real, this.Flag);
                    fprintf(docID, texto);
                else
                    imprime_resultados_criterio(this, sprintf('%d, Linea %d',po, supr.Id_real), nombre_doc, false);
                end
                for f = 1:numel(fields)
                    if this.ListaLineas(i) == 1
                       this.Lineas.(fields{f}) = [supr.(fields{f});...
                             this.Lineas.(fields{f})(this.ListaLineas(i):end)];
                    else
                        this.Lineas.(fields{f}) = ...
                            [this.Lineas.(fields{f})(1:this.ListaLineas(i)-1);supr.(fields{f});...
                             this.Lineas.(fields{f})(this.ListaLineas(i):end)];
                    end
                end
            end
            
            % Trafos
            for i = 1:numel(this.ListaTrafos)
                this.Perdidas = complex(0,0);
                % actualiz matriz Adm
                this.Adm = this.Adm_init;
                [y11, y12, y21, y22] = entrega_cuadripolo_trafo(this);
                this.Subestaciones = this.Subestaciones_init;
                n = this.Subestaciones.Id(this.Trafos.Bus1(this.ListaTrafos(i)));
                m = this.Subestaciones.Id(this.Trafos.Bus2(this.ListaTrafos(i)));
                this.Adm(n,m) = this.Adm(n,m) - y12(this.ListaTrafos(i));
                this.Adm(m,n) = this.Adm(m,n) - y21(this.ListaTrafos(i));
                this.Adm(n,n) = this.Adm(n,n) - y11(this.ListaTrafos(i));
                this.Adm(m,m) = this.Adm(m,m) - y22(this.ListaTrafos(i));
                
                supr = struct();
                fields = fieldnames(this.Trafos);
                for f = 1:numel(fields)
                    supr.(fields{f}) = [];
                    supr.(fields{f}) = this.Trafos.(fields{f})(this.ListaTrafos(i));
                    this.Trafos.(fields{f})(this.ListaTrafos(i)) = [];
                end
                this.num.Trafos = numel(this.Trafos.Id);
                this.Trafos.Id = (1:this.num.Trafos)';
                this.Subestaciones.Trafos = cell(this.num.Subestaciones);
                for f = 1:this.num.Subestaciones
                    this.Subestaciones.Trafos(f) = {[this.Trafos.Id(this.Trafos.Bus1 == f)',...
                                                     this.Trafos.Id(this.Trafos.Bus2 == f)']};
                end
                
                [~] = calcula_flujo_potencia(this, po);
                if this.Flag > 1
                    docID = fopen(nombre_doc, 'a+');
                    texto = sprintf('Resultado flujo de potencias para hora %d Trafo %d\nNo functiona porque Flag = %d\n',...
                        po, this.ListaTrafos(i), this.Flag);
                    fprintf(docID, texto);
                else
                    imprime_resultados_criterio(this,...
                        sprintf('%d Trafo %d',po, this.ListaTrafos(i)),...
                        nombre_doc, false);
                end
                for f = 1:numel(fields)
                    if this.ListaTrafos(i) == 1
                       this.Trafos.(fields{f}) = [supr.(fields{f});...
                             this.Trafos.(fields{f})(this.ListaTrafos(i):end)];
                    else
                        this.Trafos.(fields{f}) = ...
                            [this.Trafos.(fields{f})(1:this.ListaTrafos(i)-1);supr.(fields{f});...
                             this.Trafos.(fields{f})(this.ListaTrafos(i):end)];
                    end
                end
            end
            this.FlagN1 = 0;
        end
    end
end