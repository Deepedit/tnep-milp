classdef cDCOPFUninodal < cOPF
    properties
		pSEP = cSistemaElectricoPotencia.empty
        pSM = cmSistemaModal.empty
        %pAdmOper = cAdministradorEscenariosOperacion.empty
		pResEvaluacion = cResultadoEvaluacionSEP.empty
        pParOpt = cParOptimizacionOPF.empty
        pAdmSc = cAdministradorEscenarios.empty
        Sbase = 0;
        
        DatosEscenarioLocal = false
        CapacidadGeneradores = []
        SerieGeneradoresERNC = []
        SerieConsumos = []
        Nro_etapa_datos_escenario = 0
        
        VariablesInicializadas = false
        
        % resultados problema de optimizacion
        ResOptimizacion
        ExitFlag
        DescripcionFlag
        Fval
        Output
        Lambda
        
        % vectores con punteros a elementos de red que corresponden a las
        % variables de operación
        VarOpt= cmElementoModal.empty;
        TipoVarOpt = cell.empty;
        UnidadesVarOpt = cell.empty;
        iCantPuntosOperacion = 0;
        
        % vector que contiene los puntos de operación
        % si no se ingresa en forma externa
        vPuntosOperacion = 1  
        
        % Parámetro de ACO. Indica la etapa correspondiente. TODO: Hay que eliminar esta variables. 
        % Por ahora se necesita para cargar los límites de la etapa
        % correspondiente. Estas se tienen que manejar directamente en el SEP
        iEtapa = 0
        
		Fobj  = [] %funcion objetivo
        Aeq = []  % matriz con restricciones de igualdad
        beq = []  % vector objetivo restricciones de igualdad
        Aineq = [] % matriz con restricciones de desigualdad
        bineq = []  % vector de desigualdades
        lb = [] %valores mínimos de variables de decisión
        ub = [] %valores máximos de variables de decisión

        InsertaResultadosEnSEP = true;
        
        % Sólo en modo debug
        NombreVariables = []
        NombreIneq = []
        NombreEq = []
        
        MuestraDetalleIteraciones = false
        
        iIndiceIneq = 0
        iIndiceEq = 0
        iNivelDebug = 2
        caso_estudio = 'caso_base'
        nombre_archivo = './output/dc_opf.dat'
        nombre_archivo_problema_opt = './output/dc_opf_problem_formulation.dat'
        nombre_archivo_detalle_variables = './output/variables_dc_opf.dat'
    end
    
    methods
	
		function this = cDCOPFUninodal(sep, varargin)                
			this.pSEP = sep;
            this.pParOpt = cParOptimizacionOPF();
            this.pResEvaluacion = cResultadoEvaluacionSEP(sep);
            this.pResEvaluacion.inserta_tipo_flujo_potencia('DC');
            this.pResEvaluacion.inserta_tipo_computo('OPF');
            this.pResEvaluacion.inserta_tipo_problema(this.pParOpt.entrega_tipo_problema());
            this.pSM = cmSistemaModal(sep, 1);
            sep.inserta_sistema_modal(this.pSM);
            this.pSM.inserta_opf(this);
            this.Sbase = cParametrosSistemaElectricoPotencia.getInstance.entrega_sbase();
            if nargin > 2
                %OPF para planificación
                this.pAdmSc = varargin{1};
                this.vPuntosOperacion = this.pAdmSc.entrega_puntos_operacion();
                this.iCantPuntosOperacion = length(this.vPuntosOperacion);
                % reemplaza parámetros del OPF por los indicados en ACO
                this.copia_parametros_optimizacion(varargin{2})
                this.DatosEscenarioLocal = false;
            else
                this.DatosEscenarioLocal = true;
            end
        end
        
        function inserta_caso_estudio(this, caso_estudio)
            this.caso_estudio = caso_estudio;
        end
        
        function inserta_etapa(this, nro_etapa)
            % etapa se utiliza para ACO
            this.iEtapa = nro_etapa;
        end
        
        function etapa = entrega_etapa(this)
            etapa = this.iEtapa;
        end
        
        function inserta_etapa_datos_escenario(this, nro_etapa)
            this.Nro_etapa_datos_escenario = nro_etapa;
            this.iEtapa = nro_etapa;
        end
        
        function etapa = entrega_etapa_datos_escenario(this)
            etapa = this.Nro_etapa_datos_escenario;
        end
        
        function inserta_sbase(this, val)
            this.Sbase = val;
        end
        
        function actualiza_etapa(this, nro_etapa)
            this.iEtapa = nro_etapa;
            cant_po = length(this.vPuntosOperacion);
            %actualiza potencias de los generadores y consumos (ens) de acuerdo a
            %la etapa
            for i = 1:length(this.VarOpt)
                elred = this.VarOpt(i).entrega_elemento_red();
                switch this.TipoVarOpt{i}
                    case 'VariableControl'
                        % Potencia de inyección del generador
                        if this.DatosEscenarioLocal
                            id_generador_sc = this.VarOpt(i).entrega_elemento_red().entrega_indice_escenario();
                            pmax = this.CapacidadGeneradores(id_generador_sc);
                            pmax = pmax/this.Sbase;
                        elseif ~isempty(this.pAdmSc)
                            % factor de expansión para TNEP
                            id_generador_sc = this.VarOpt(i).entrega_elemento_red().entrega_indice_escenario();
                            pmax = this.pAdmSc.entrega_capacidad_generador(id_generador_sc, this.iEtapa);
                            pmax = pmax/this.Sbase;
                        else
                            pmax = elred.entrega_pmax_pu();                                
                        end
                        pmin = elred.entrega_pmin_pu();

                        if strcmp(this.pParOpt.entrega_tipo_problema(), 'Redespacho')
                            % problema de redespacho. se
                            % consideran los delta de los
                            % límites
                            if elred.es_despachable()
                                p0 = elred.entrega_p0_pu();
                                pmax = pmax - p0;
                                pmin = p0 - pmin;
                            end
                        end
                        indice_varopt_operacion_desde = this.VarOpt(i).entrega_varopt_operacion('P', 1);
                        indice_varopt_operacion_hasta = this.VarOpt(i).entrega_varopt_operacion('P', 2);
                        this.lb(indice_varopt_operacion_desde:indice_varopt_operacion_hasta) = round(pmin,5);
                        this.ub(indice_varopt_operacion_desde:indice_varopt_operacion_hasta) = round(pmax,5);
                        %if this.iNivelDebug > 1
                        %    this.ingresa_nombres(indice, oper, this.TipoVarOpt{i}, this.UnidadesVarOpt{i});
                        %end
                    case 'VariableEstado'
                        % nada que hacer, ya que ángulo de las
                        % subestaciones ya fueron definidos
                    case 'VariableAuxiliar'
                        switch this.UnidadesVarOpt{i}
                            case 'P'
                                % potencia activa de líneas y
                                % transformadores o energia no
                                % suministrada o recorte res
                                if isa(elred, 'cLinea') || isa(elred, 'cTransformador2D')
                                    % nada que hacer, ya que límites ya
                                    % fueron definidos
                                elseif isa(elred, 'cConsumo')
                                    %actualiza condumos
                                    indice_varopt_operacion_desde = this.VarOpt(i).entrega_varopt_operacion('P', 1);
                                    indice_varopt_operacion_hasta = this.VarOpt(i).entrega_varopt_operacion('P', 2);
                                    if this.DatosEscenarioLocal
                                        id_consumo_sc = elred.entrega_indice_escenario();
                                        consumo_max = this.SerieConsumos(id_consumo_sc, :);
                                        consumo_max = consumo_max/this.Sbase;
                                    elseif ~isempty(this.pAdmSc)
                                        % factor de expansión para TNEP
                                        id_consumo_sc = elred.entrega_indice_escenario();
                                        desde = 1 + (this.iEtapa - 1)*cant_po;
                                        hasta = this.iEtapa*cant_po;
                                        consumo_max = this.pAdmSc.SerieConsumos(id_consumo_sc, desde:hasta)/this.Sbase;                                        
                                    else
                                        % sólo un PO
                                        consumo_max = -elred.entrega_p_const_nom_pu(); %valor positivo
                                    end
                                    %this.lb(indice) = 0;
                                    this.ub(indice_varopt_operacion_desde:indice_varopt_operacion_hasta) = round(consumo_max,5);
                                elseif isa(elred, 'cGenerador')
                                    indice_varopt_operacion_desde = this.VarOpt(i).entrega_varopt_operacion('P', 1);
                                    indice_varopt_operacion_hasta = this.VarOpt(i).entrega_varopt_operacion('P', 2);
                                    if this.DatosEscenarioLocal
                                        id_generador_sc = this.VarOpt(i).entrega_elemento_red().entrega_indice_escenario();
                                        pmax = this.SerieGeneradoresERNC(id_generador_sc, :);
                                        pmax = pmax/this.Sbase;
                                    elseif ~isempty(this.pAdmSc)
                                        % factor de expansión para TNEP
                                        id_generador_sc = this.VarOpt(i).entrega_elemento_red().entrega_indice_escenario();
                                        desde = 1 + (this.iEtapa - 1)*cant_po;
                                        hasta = this.iEtapa*cant_po;
                                        pmax = this.pAdmSc.SerieGeneradoresERNC(id_generador_sc, desde:hasta);
                                        pmax = pmax/this.Sbase;
                                    else
                                        % sólo un punto de operacion
                                        pmax = elred.entrega_pmax_pu();                                
                                    end
                                    this.ub(indice_varopt_operacion_desde:indice_varopt_operacion_hasta) = round(pmax',5);
                                else
                                    error = MException('cOPF:actualiza_etapa',...
                                        ['Inconsistencia en los datos en variable auxiliar P. Elemento de red ' class(elred) ' no corresponde']);
                                    throw(error)
                                end
                            otherwise
                                error = MException('cOPF:actualiza_etapa',...
                                    ['Inconsistencia en los datos en variable auxiliar. Tipo ' this.UnidadesVarOpt{i} ' no corresponde']);
                                throw(error)
                        end
                    otherwise
                        error = MException('cOPF:actualiza_etapa',...
                            ['Inconsistencia en los datos. Tipo de variable de control ' this.TipoVarOpt{i} ' no corresponde']);
                        throw(error)
                end
            end

            %actualiza balance de energía
            pBuses = this.pSM.entrega_buses();
            for i = 1:length(pBuses)
                id_restriccion_be_desde = pBuses(i).entrega_indice_restriccion_balance_energia(1);
                id_restriccion_be_hasta = pBuses(i).entrega_indice_restriccion_balance_energia(2);

                %consumo residual
                if this.DatosEscenarioLocal || ~isempty(this.pAdmSc)
                    consumo_residual_p = zeros(cant_po,1);
                    elpar = pBuses(i).entrega_elementos_paralelos();
                    for ii = 1:length(elpar)
                        valor_elemento = zeros(1,cant_po);
                        el_red = elpar(ii).entrega_elemento_red();
                        if isa(el_red, 'cConsumo')
                            indice = el_red.entrega_indice_escenario();
                            if this.DatosEscenarioLocal
                                valor_elemento = -this.SerieConsumos(indice, :)/this.Sbase;
                            else
                                desde = 1 + (this.iEtapa - 1)*cant_po;
                                hasta = this.iEtapa*cant_po;
                                valor_elemento = -this.pAdmSc.SerieConsumos(indice, desde:hasta)/this.Sbase;
                            end
                        elseif isa(el_red, 'cGenerador')
                            if el_red.es_ernc()
                                indice = el_red.entrega_indice_escenario();
                                if this.DatosEscenarioLocal
                                    valor_elemento = this.SerieGeneradoresERNC(indice, :)/this.Sbase;
                                else
                                    desde = 1 + (this.iEtapa - 1)*cant_po;
                                    hasta = this.iEtapa*cant_po;
                                    valor_elemento = this.pAdmSc.SerieGeneradoresERNC(indice, desde:hasta)/this.Sbase;                                    
                                end
                            end
                        end
                        consumo_residual_p = consumo_residual_p + valor_elemento';
                    end
                else
                    % sólo un punto de operación
                    consumo_residual_p = pBuses(i).entrega_p_const_nom_opf();
                end
                this.beq(id_restriccion_be_desde:id_restriccion_be_hasta) = round(-consumo_residual_p,5);
            end
        end
        
        function inserta_puntos_operacion(this, po)
            this.vPuntosOperacion = po;
            this.iCantPuntosOperacion = length(this.vPuntosOperacion);
        end
        
        function inserta_datos_escenario(this, datos_escenario)
            this.CapacidadGeneradores = datos_escenario.CapacidadGeneradores;
            this.SerieGeneradoresERNC = datos_escenario.SerieGeneradoresERNC;
            this.SerieConsumos = datos_escenario.SerieConsumos;
        end
        
        function inserta_nivel_debug(this, nivel)
            this.iNivelDebug = nivel;
        end
        
        function nivel = entrega_nivel_debug(this)
            nivel = this.iNivelDebug;
        end
        
        function inserta_resultados_en_sep(this, val)
            this.InsertaResultadosEnSEP = val;
        end
        
		function calcula_despacho_economico(this)
            if this.VariablesInicializadas == false
                this.iIndiceIneq = 0;
                this.iIndiceEq = 0;
                this.inicializa_variables();
                this.inicializa_contenedores();
			
                this.escribe_funcion_objetivo();
                this.escribe_restricciones();
                this.VariablesInicializadas = true;
            end
            if this.iNivelDebug > 1
                this.imprime_problema_optimizacion();
            end
            
			this.optimiza();
            this.pResEvaluacion.inicializa_contenedores(length(this.vPuntosOperacion));
            if this.ExitFlag == 1
                % problema tiene solucion óptima
                this.pResEvaluacion.ExisteResultado = true;
                this.escribe_resultados();
                if this.iNivelDebug > 0
                    this.imprime_resultados_protocolo();
                end
            else
                this.pResEvaluacion.ExisteResultado = false;
                if this.iNivelDebug > 0
                    prot = cProtocolo.getInstance;
                    prot.imprime_texto('Problema de optimizacion invalido');
                    prot.imprime_texto(['Estado flag: ' num2str(this.ExitFlag)]);
                end
                % problema no tiene solucion
                % no se escriben resultados porque no tiene sentido
            end
        end
                
        function formula_problema_despacho_economico(this)
            this.iIndiceIneq = 0;
            this.iIndiceEq = 0;
            this.inicializa_variables();
            this.inicializa_contenedores();
			
            this.escribe_funcion_objetivo();
            this.escribe_restricciones();
            this.VariablesInicializadas = true;
        end
        
        function inicializa_variables(this)
            % Primero crea las variables de optimización y luego las
            % inicializa
            
            % variables de control (cuando flag opf esté activada): 
            % 1. potencia activa (despacho) de los generadores. También se
            % consideran los generadores RES en caso de que flag opf esté
            % activada
            % 
            % Variables de estado:
            % 2. Ángulos de los buses (la Slack se fija en cero pero se incluye como variable)
            %
            % Variables auxiliares (ayudan a la formulación del problema)
            % 2. Flujos por las líneas y transformadores.
            % 3. Consumos (para energía no suministrada)
            
            % variables de control.
            this.inserta_varopt(this.pSM.entrega_generadores_despachables(), 'VariableControl', 'P');
                
            % variables de estado
            this.inserta_varopt(this.pSM.entrega_buses(), 'VariableEstado', 'Theta');
            
            % variables auxiliares.
            %mlineas = this.pSM.entrega_elemento_serie('cLinea');
            %this.inserta_varopt(mlineas, 'VariableAuxiliar', 'P');
            
            %mtrafo2d = this.pSM.entrega_elemento_serie('cTransformador2D');
            %this.inserta_varopt(mtrafo2d, 'VariableAuxiliar', 'P')

            if this.pParOpt.considera_desprendimiento_carga()
                mconsumo = this.pSM.entrega_elemento_paralelo('cConsumo');
                this.inserta_varopt(mconsumo, 'VariableAuxiliar', 'P');
            end

            if this.pParOpt.ConsideraRecorteRES
                this.inserta_varopt(this.pSM.entrega_generadores_ernc(), 'VariableAuxiliar', 'P');
            end
            
            % Inicializa las variables
            if this.iNivelDebug > 1
                this.NombreVariables = cell(length(this.VarOpt)*length(this.vPuntosOperacion),1);
            end

            cant_po = length(this.vPuntosOperacion);
            for i = 1:length(this.VarOpt)
                indice_desde = cant_po*(i-1) + 1;
                indice_hasta = cant_po*i;
                elred = this.VarOpt(i).entrega_elemento_red();
                switch this.TipoVarOpt{i}
                    case 'VariableControl'
                        % Potencia de inyección de generador
                        % despachable
                        %elred.inserta_flag_opf(true);
                        if this.DatosEscenarioLocal
                            id_generador_sc = this.VarOpt(i).entrega_elemento_red().entrega_indice_escenario();
                            pmax = this.CapacidadGeneradores(id_generador_sc);
                            pmax = pmax/this.Sbase;
                        elseif ~isempty(this.pAdmSc)
                            % factor de expansión para TNEP
                            id_generador_sc = this.VarOpt(i).entrega_elemento_red().entrega_indice_escenario();
                            pmax = this.pAdmSc.entrega_capacidad_generador(id_generador_sc, this.iEtapa);
                            pmax = pmax/this.Sbase;
                        else
                            pmax = elred.entrega_pmax_pu();                                
                        end
                        pmin = elred.entrega_pmin_pu();

                        if strcmp(this.pParOpt.entrega_tipo_problema(), 'Redespacho')
                            % problema de redespacho. se
                            % consideran los delta de los
                            % límites
                            if elred.es_despachable()
                                p0 = elred.entrega_p0_pu();
                                pmax = pmax - p0;
                                pmin = p0 - pmin;
                            end
                        end
                        this.VarOpt(i).inserta_varopt_operacion('P', 1, indice_desde);
                        this.VarOpt(i).inserta_varopt_operacion('P', 2, indice_hasta);
                        this.lb(indice_desde:indice_hasta) = round(pmin,5);
                        this.ub(indice_desde:indice_hasta) = round(pmax,5);

                        if this.iNivelDebug > 0                      
                            this.ingresa_nombres(i, indice_desde, this.TipoVarOpt{i}, this.UnidadesVarOpt{i});
                        end
                    case 'VariableEstado'
                        % ángulo de las subestaciones 
                        this.VarOpt(i).inserta_varopt_operacion('Theta', 1, indice_desde);
                        this.VarOpt(i).inserta_varopt_operacion('Theta', 2, indice_hasta);
                        if this.VarOpt(i).es_slack()
                            this.lb(indice_desde:indice_hasta) = 0;
                            this.ub(indice_desde:indice_hasta) = 0;
                        else
                            this.lb(indice_desde:indice_hasta) = round(-pi,5);
                            this.ub(indice_desde:indice_hasta) = round(pi,5);
                        end
                        if this.iNivelDebug > 0
                            this.ingresa_nombres(i, indice_desde, this.TipoVarOpt{i}, this.UnidadesVarOpt{i});
                        end
                    case 'VariableAuxiliar'
                        switch this.UnidadesVarOpt{i}
                            case 'P'
                                % potencia activa de líneas y
                                % transformadores o energia no
                                % suministrada
                                this.VarOpt(i).inserta_varopt_operacion('P', 1, indice_desde);
                                this.VarOpt(i).inserta_varopt_operacion('P', 2, indice_hasta);
                                elred = this.VarOpt(i).entrega_elemento_red(); 
                                if isa(elred, 'cLinea') || isa(elred, 'cTransformador2D')
                                    sr = elred.entrega_sr_pu();
                                    this.lb(indice_desde:indice_hasta) = -sr;
                                    this.ub(indice_desde:indice_hasta) = sr;
                                elseif isa(elred, 'cConsumo')
                                    if this.DatosEscenarioLocal
                                        id_consumo_sc = elred.entrega_indice_escenario();
                                        consumo_max = this.SerieConsumos(id_consumo_sc, :);
                                        consumo_max = consumo_max/this.Sbase;
                                    elseif ~isempty(this.pAdmSc)
                                        % factor de expansión para TNEP
                                        id_consumo_sc = elred.entrega_indice_escenario();
                                        desde = 1 + (this.iEtapa - 1)*cant_po;
                                        hasta = this.iEtapa*cant_po;
                                        consumo_max = this.pAdmSc.SerieConsumos(id_consumo_sc,desde:hasta)/this.Sbase;                                        
                                    else
                                        % sólo un punto de operación
                                        consumo_max = -elred.entrega_p_const_nom_pu(); %valor positivo
                                    end
                                    this.lb(indice_desde:indice_hasta) = 0;
                                    this.ub(indice_desde:indice_hasta) = round(consumo_max',5);
                                elseif isa(elred, 'cGenerador')
                                    if this.DatosEscenarioLocal
                                        id_generador_sc = this.VarOpt(i).entrega_elemento_red().entrega_indice_escenario();
                                        pmax = this.SerieGeneradoresERNC(id_generador_sc, :);
                                        pmax = pmax/this.Sbase;
                                    elseif ~isempty(this.pAdmSc)
                                        % factor de expansión para TNEP
                                        id_generador_sc = this.VarOpt(i).entrega_elemento_red().entrega_indice_escenario();
                                        desde = 1 + (this.iEtapa - 1)*cant_po;
                                        hasta = this.iEtapa*cant_po;
                                        pmax = this.pAdmSc.SerieGeneradoresERNC(id_generador_sc, desde:hasta);

                                        pmax = pmax/this.Sbase;
                                    else
                                        % sólo un punto de operación
                                        pmax = elred.entrega_pmax_pu();                                
                                    end
                                    this.lb(indice_desde:indice_hasta) = 0;
                                    this.ub(indice_desde:indice_hasta) = round(pmax',5);                                        
                                else
                                    error = MException('cOPF:inicializa_variables',...
                                        ['Inconsistencia en los datos en variable auxiliar P. Elemento de red ' class(elred) ' no corresponde']);
                                    throw(error)
                                end
                                if this.iNivelDebug > 0
                                    this.ingresa_nombres(i, indice_desde, this.TipoVarOpt{i}, this.UnidadesVarOpt{i});
                                end
                            otherwise
                                error = MException('cOPF:inicializa_variables',...
                                    ['Inconsistencia en los datos en variable auxiliar. Tipo ' this.UnidadesVarOpt{i} ' no corresponde']);
                                throw(error)
                        end
                    otherwise
                        error = MException('cOPF:inicializa_variables',...
                            ['Inconsistencia en los datos. Tipo de variable de control ' this.TipoVarOpt{i} ' no corresponde']);
                        throw(error)
                end
            end
        end

        function agrega_variable(this, variable)
            % variable es elemento del sistema modal
            % Esta función es peligrosa. Fue definida sólo para
            % TNEP para mejorar performance!
            
            indice = length(this.Fobj);
            % agrega nueva variable a función objetivo. Como sólo se
            % trata de nuevas líneas y transformadores, estos no afectan a
            % la función objetivo
            this.Fobj = [this.Fobj; zeros(length(this.vPuntosOperacion), 1)];

            % actualiza dimensión de restricciones de igualdad
            this.Aeq = [this.Aeq zeros(this.iIndiceEq, length(this.vPuntosOperacion))];
            
            indice_desde = indice + 1;
            indice_hasta = indice + length(this.vPuntosOperacion);
            
            if isa(variable, 'cmBus')
                this.agrega_varopt(variable, 'VariableEstado', 'Theta');                
                variable.inserta_varopt_operacion('Theta', 1, indice_desde);
                variable.inserta_varopt_operacion('Theta', 2, indice_hasta);
                this.lb(indice_desde:indice_hasta) = round(-pi,5);
                this.ub(indice_desde:indice_hasta) = round(pi,5);
                if this.iNivelDebug > 0
                    this.ingresa_nombres(length(this.VarOpt), indice_desde, 'VariableEstado', 'Theta');
                end

                % agrega nueva restricción para balance de energía
                this.agrega_balance_energia(variable);
            elseif isa(variable, 'cmElementoSerie')
                this.agrega_varopt(variable, 'VariableAuxiliar', 'P');
                variable.inserta_varopt_operacion('P', 1, indice_desde);
                variable.inserta_varopt_operacion('P', 2, indice_hasta);
                elred = variable.entrega_elemento_red(); 
                if isa(elred, 'cLinea') || isa(elred, 'cTransformador2D')
                    sr = elred.entrega_sr_pu();
                    this.lb(indice_desde:indice_hasta) = -sr;
                    this.ub(indice_desde:indice_hasta) = sr;
                else
                    error = MException('cOPF:agrega_variable','Tipo de variable serie aún no implementada. Sólo líneas y transformadores');
                    throw(error)
                end
                if this.iNivelDebug > 0
                    this.ingresa_nombres(length(this.VarOpt), indice_desde, 'VariableAuxiliar', 'P');
                end
                this.actualiza_balance_energia(variable);
                this.agrega_relaciones_flujos_angulos(variable)
            else
                error = MException('cOPF:agrega_variable','Tipo de variable aún no implementada. Sólo buses y elementos serie. Ningún elemento paralelo');
                throw(error)
            end
        end

        function elimina_variable(this, variable)
            % variable es elemento del sistema modal
            % Esta función es peligrosa. Fue definida sólo para
            % TNEP para mejorar performance!
            cant_po = length(this.vPuntosOperacion);
            % primero identifica id de restricción
            if isa(variable, 'cmBus')
                indice_varopt_operacion_desde = variable.entrega_varopt_operacion('Theta',1);
                indice_varopt_operacion_hasta = variable.entrega_varopt_operacion('Theta',2);
                % se elimina balance de energía. Se verifica eso sí que no
                % haya ningún elemento conectado aún
                id_restriccion_desde = variable.entrega_indice_restriccion_balance_energia(1);
                id_restriccion_hasta = variable.entrega_indice_restriccion_balance_energia(2);
                
                if ~isempty(nonzeros(this.Aeq(id_restriccion_desde:id_restriccion_hasta,:)))
                    error = MException('cOPF:elimina_variable','Error de programación. No se puede eliminar bus, porque aún existen variables en balance de energía!');
                    throw(error)
                end
            elseif isa(variable, 'cmElementoSerie')
                indice_varopt_operacion_desde = variable.entrega_varopt_operacion('P',1);
                indice_varopt_operacion_hasta = variable.entrega_varopt_operacion('P',2);
                %elimina variable de balance de energía

                id_restriccion_desde = variable.entrega_indice_restriccion_flujos_angulos(1);
                id_restriccion_hasta = variable.entrega_indice_restriccion_flujos_angulos(2);
            else
                error = MException('cOPF:elimina_variable','Error de programación. Sólo se pueden eliminar buses o elementos serie. No elementos paralelos');
                throw(error)
            end

            % elimina restriccion
            this.Aeq(id_restriccion_desde:id_restriccion_hasta,:) = [];
            this.beq(id_restriccion_desde:id_restriccion_hasta) = [];
            this.iIndiceEq = this.iIndiceEq - cant_po;

            if ~isempty(this.NombreEq)
                this.NombreEq(id_restriccion_desde:id_restriccion_hasta) = [];
            end

            %actualiza índices de restricciones de igualdad para el resto
            %de los elementos (buses y elementos serie). 
            %RAMRAM TODO: Eventualmente un método más eficiente?
            for i = 1:length(this.VarOpt)
                if isa(this.VarOpt(i), 'cmBus')
                    id_be_desde = this.VarOpt(i).entrega_indice_restriccion_balance_energia(1);
                    id_be_hasta = this.VarOpt(i).entrega_indice_restriccion_balance_energia(2);

                    if id_be_desde > id_restriccion_desde
                        this.VarOpt(i).agrega_indice_restriccion_balance_energia(1, id_be_desde - cant_po);
                        this.VarOpt(i).agrega_indice_restriccion_balance_energia(2, id_be_hasta - cant_po);
                    end
                elseif isa(this.VarOpt(i), 'cmElementoSerie')
                    id_fa_desde = this.VarOpt(i).entrega_indice_restriccion_flujos_angulos(1);
                    id_fa_hasta = this.VarOpt(i).entrega_indice_restriccion_flujos_angulos(2);
                    if id_fa_desde > id_restriccion_desde
                        this.VarOpt(i).agrega_indice_restriccion_flujos_angulos(1,id_fa_desde - cant_po);
                        this.VarOpt(i).agrega_indice_restriccion_flujos_angulos(2,id_fa_hasta - cant_po);
                    end
                end
            end

            % elimina variable de contenedores
            this.Fobj(indice_varopt_operacion_desde:indice_varopt_operacion_hasta) = [];
            this.lb(indice_varopt_operacion_desde:indice_varopt_operacion_hasta) = [];
            this.ub(indice_varopt_operacion_desde:indice_varopt_operacion_hasta) = [];
            if ~isempty(this.NombreVariables)
                this.NombreVariables(indice_varopt_operacion_desde:indice_varopt_operacion_hasta) = [];
            end
            this.Aeq(:,indice_varopt_operacion_desde:indice_varopt_operacion_hasta) = [];

            % actualiza índice del resto de las variables
            % TODO RAMRAM: Puede no ser eficiente... alternativa?
            for i = 1:length(this.VarOpt)
                if isa(this.VarOpt(i), 'cmBus')
                    id_varopt_op_desde = this.VarOpt(i).entrega_varopt_operacion('Theta',1);
                    id_varopt_op_hasta = this.VarOpt(i).entrega_varopt_operacion('Theta',2);
                    if id_varopt_op_desde > indice_varopt_operacion_desde
                        this.VarOpt(i).inserta_varopt_operacion('Theta', 1, id_varopt_op_desde - cant_po);
                        this.VarOpt(i).inserta_varopt_operacion('Theta', 2, id_varopt_op_hasta - cant_po);
                    end
                else
                    id_varopt_op_desde = this.VarOpt(i).entrega_varopt_operacion('P',1);
                    id_varopt_op_hasta = this.VarOpt(i).entrega_varopt_operacion('P',2);
                    if id_varopt_op_desde > indice_varopt_operacion_desde
                        this.VarOpt(i).inserta_varopt_operacion('P', 1,id_varopt_op_desde - cant_po);
                        this.VarOpt(i).inserta_varopt_operacion('P', 2,id_varopt_op_hasta - cant_po);
                    end
                end
            end
            
            % finalmente se borra varopt
            id_varopt = variable.entrega_indice_varopt();
            this.VarOpt(id_varopt) = [];
            this.TipoVarOpt(id_varopt) = [];
            this.UnidadesVarOpt(id_varopt) = [];

            for i = 1:length(this.VarOpt)
                id_otro = this.VarOpt(i).entrega_indice_varopt();
                if id_otro > id_varopt
                    this.VarOpt(i).inserta_indice_varopt(id_otro-1);
                end
            end
        end
        
        function inicializa_contenedores(this)
            % se inicializan las dimensiones de las matrices. 

            n_var = length(this.VarOpt)*this.iCantPuntosOperacion;
            this.Fobj = zeros(n_var, 1);
            
            % Restricciones de igualdad contiene: 
            % 1. Balance de energía
            % 2. Restricciones flujos-ángulos
            %    Cantidad: #elementos serie *#po

            n_buses = this.pSM.entrega_cantidad_buses();
            n_serie = this.pSM.entrega_cantidad_elementos_serie();
            cantidad_eq = (n_buses+n_serie)*this.iCantPuntosOperacion;
     
            this.Aeq = sparse(cantidad_eq, n_var);
            this.beq = zeros(cantidad_eq, 1);
            %this.NombreEq = cell(cantidad_rest_igualdad,1);        
            if this.iNivelDebug > 0
                this.NombreEq = cell(cantidad_eq,1);
            end
            % por ahora no hay restricciones de desigualdad
            cantidad_ineq = 0;
            this.Aineq = [];
            this.bineq = [];
            
            if this.iNivelDebug > 1
                prot = cProtocolo.getInstance;
                prot.imprime_texto('Dimension de contenedores (antes de escribir las restricciones)');
                prot.imprime_texto(['Cantidad variables decision: ' num2str(n_var)]);
                prot.imprime_texto(['Cantidad rest. igualdad: ' num2str(cantidad_eq)]);
                prot.imprime_texto(['Cantidad rest. desigualdad: ' num2str(cantidad_ineq)]);
            end
        end
        
        function escribe_funcion_objetivo(this)
            if strcmp(this.pParOpt.entrega_funcion_objetivo(), 'MinC')
                    % Costo de generación
                    % no es eficiente pero en este punto no se necesita
                    % rapidez (... o si? TODO: Evaluar!)
                    for i = 1:length(this.VarOpt)
                        elred = this.VarOpt(i).entrega_elemento_red();
                        if isa(elred, 'cGenerador')
                            if strcmp(this.TipoVarOpt{i}, 'VariableControl')
                                costo_mwh = elred.entrega_costo_mwh_pu();
                                indice_desde = this.VarOpt(i).entrega_varopt_operacion('P',1);
                                indice_hasta = this.VarOpt(i).entrega_varopt_operacion('P',2);
                                this.Fobj(indice_desde:indice_hasta) = round(costo_mwh,5);
                            elseif strcmp(this.TipoVarOpt{i}, 'VariableAuxiliar')
                                penalizacion = this.pParOpt.entrega_penalizacion_recorte_res(); % en $/MWh
                                sbase = cParametrosSistemaElectricoPotencia.getInstance.entrega_sbase();
                                indice_desde = this.VarOpt(i).entrega_varopt_operacion('P',1);
                                indice_hasta = this.VarOpt(i).entrega_varopt_operacion('P',2);
                                this.Fobj(indice_desde:indice_hasta) = round(penalizacion*sbase,5);
                            end
                        elseif isa(elred, 'cConsumo')
                            costo_desconexion = elred.entrega_costo_desconexion_carga_pu();
                            if costo_desconexion == 0
                                error = MException('cOPF:escribe_funcion_objetivo','Costo de desconexión de carga igual a cero');
                                throw(error)
                            end
                            indice_desde = this.VarOpt(i).entrega_varopt_operacion(this.UnidadesVarOpt{i}, 1);
                            indice_hasta = this.VarOpt(i).entrega_varopt_operacion(this.UnidadesVarOpt{i}, 2);
                            this.Fobj(indice_desde:indice_hasta) = round(costo_desconexion,5);
                        end
                    end
            else
                error = MException('cOPF:escribe_funcion_objetivo','Función objetivo indicada no implementada');
                throw(error)
            end
        end
        
        function escribe_restricciones(this)
            this.escribe_balance_energia();
            this.escribe_relaciones_flujos_angulos();
            % no se necesita restringir el ángulo máximo entre los
            % buses, ya que flujo máximo por las líneas es más
            % restrictivo
            %this.escribe_restricciones_angulos_buses(oper);
        end

        function escribe_balance_energia(this)
            pBuses = this.pSM.entrega_buses();
            cant_po = length(this.vPuntosOperacion);
            for i = 1:length(pBuses)
                indice_eq_desde = this.iIndiceEq +1;
                indice_eq_hasta = this.iIndiceEq +cant_po;                
                this.iIndiceEq = this.iIndiceEq +cant_po;
                pBuses(i).agrega_indice_restriccion_balance_energia(1, indice_eq_desde);
                pBuses(i).agrega_indice_restriccion_balance_energia(2, indice_eq_hasta);
                
                % Balance de potencia activa en bus
                %generadores
                pGeneradores = pBuses(i).entrega_generadores_despachables();
                for j = 1:length(pGeneradores)
                    indice_gen_desde = pGeneradores(j).entrega_varopt_operacion('P', 1);
                    indice_gen_hasta = pGeneradores(j).entrega_varopt_operacion('P', 2);
                    this.Aeq(indice_eq_desde:indice_eq_hasta,indice_gen_desde:indice_gen_hasta) = this.Aeq(indice_eq_desde:indice_eq_hasta,indice_gen_desde:indice_gen_hasta) + diag(ones(cant_po,1));
                    %for oper = 1:cant_po
                    %    this.Aeq(indice_eq_desde + oper - 1,indice_gen_desde + oper - 1) = 1;
                    %end
                end

                %ENS
                if this.pParOpt.considera_desprendimiento_carga()
                    pConsumos = pBuses(i).entrega_consumos();
                    for j = 1:length(pConsumos)
                        indice_consumo_desde = pConsumos(j).entrega_varopt_operacion('P', 1);
                        indice_consumo_hasta = pConsumos(j).entrega_varopt_operacion('P', 2);
                        this.Aeq(indice_eq_desde:indice_eq_hasta,indice_consumo_desde:indice_consumo_hasta) = this.Aeq(indice_eq_desde:indice_eq_hasta,indice_consumo_desde:indice_consumo_hasta) + diag(ones(cant_po,1));
                        %for oper = 1:cant_po
                        %    this.Aeq(indice_eq_desde + oper - 1,indice_consumo_desde + oper - 1) = 1;
                        %end
                    end
                end
                
                % Recorte RES.
                if this.pParOpt.ConsideraRecorteRES
                    pGeneradores_ernc = pBuses(i).entrega_generadores_ernc();
                    for j = 1:length(pGeneradores_ernc)
                        indice_generador_desde = pGeneradores_ernc(j).entrega_varopt_operacion('P', 1);
                        indice_generador_hasta = pGeneradores_ernc(j).entrega_varopt_operacion('P', 2);
                        this.Aeq(indice_eq_desde:indice_eq_hasta,indice_generador_desde:indice_generador_hasta) = this.Aeq(indice_eq_desde:indice_eq_hasta,indice_generador_desde:indice_generador_hasta) + diag(ones(cant_po,1))*-1;
                        %for oper = 1:cant_po
                        %    this.Aeq(indice_eq_desde + oper - 1,indice_generador_desde + oper - 1) = -1;
                        %end
                    end
                end
                
                %consumo residual
                consumo_residual_p = zeros(cant_po,1);
                if this.DatosEscenarioLocal || ~isempty(this.pAdmSc)
                    elpar = pBuses(i).entrega_elementos_paralelos();
                    for ii = 1:length(elpar)
                        valor_elemento = zeros(1,cant_po);
                        el_red = elpar(ii).entrega_elemento_red();
                        if isa(el_red, 'cConsumo')
                            indice = el_red.entrega_indice_escenario();
                            if this.DatosEscenarioLocal
                                valor_elemento = -this.SerieConsumos(indice, :)/this.Sbase;
                            else
                                desde = 1 + (this.iEtapa - 1)*cant_po;
                                hasta = this.iEtapa*cant_po;
                                valor_elemento= -this.pAdmSc.SerieConsumos(indice, desde:hasta)/this.Sbase;
                            end
                        elseif isa(el_red, 'cGenerador')
                            if el_red.es_ernc()
                                indice = el_red.entrega_indice_escenario();
                                if this.DatosEscenarioLocal
                                    valor_elemento = this.SerieGeneradoresERNC(indice, :)/this.Sbase;
                                else
                                    desde = 1 + (this.iEtapa - 1)*cant_po;
                                    hasta = this.iEtapa*cant_po;
                                    valor_elemento = this.pAdmSc.SerieGeneradoresERNC(indice, desde:hasta)/this.Sbase;
                                end
                            end
                        end
                        consumo_residual_p = consumo_residual_p + valor_elemento';
                    end
                else
                    % sólo un punto de operación
                    consumo_residual_p = pBuses(i).entrega_p_const_nom_opf();
                end
                this.beq(indice_eq_desde:indice_eq_hasta) = round(-consumo_residual_p,5);

                % elementos serie
                eserie = pBuses(i).entrega_elementos_serie();
                for j = 1:length(eserie)
                    indice_eserie_p_desde = eserie(j).entrega_varopt_operacion('P', 1);
                    indice_eserie_p_hasta = eserie(j).entrega_varopt_operacion('P', 2);
                    
                    bus1 = eserie(j).entrega_bus1();
                    bus2 = eserie(j).entrega_bus2();
                    if bus1 == pBuses(i)
                        % inicio linea corresponde a este bus, por lo tanto
                        % flujo sale
                        signo = -1;
                    elseif bus2 == pBuses(i)
                        signo = 1;
                    else
                        error = MException('cOPF:escribe_balance_energia','Inconsistencia en los datos, ya que elemento serie no pertenece a bus');
                        throw(error)
                    end
                    
                    this.Aeq(indice_eq_desde:indice_eq_hasta,indice_eserie_p_desde:indice_eserie_p_hasta) = this.Aeq(indice_eq_desde:indice_eq_hasta,indice_eserie_p_desde:indice_eserie_p_hasta) + diag(ones(cant_po,1))*signo;
                    %for oper = 1:cant_po
                    %    this.Aeq(indice_eq_desde + oper - 1,indice_eserie_p_desde + oper - 1) = signo;
                    %end
                    if this.iNivelDebug > 0
                        for oper = 1:cant_po                        
                            this.NombreEq{indice_eq_desde + oper - 1} = strcat('req_', num2str(indice_eq_desde + oper - 1), '_be_', 'B', num2str(pBuses(i).entrega_id_global()), '_O', num2str(oper));
                        end
                    end
                end
            end
        end

        function actualiza_balance_energia(this, variable)
            cant_po = length(this.vPuntosOperacion);
            indice_eserie_p_desde = variable.entrega_varopt_operacion('P', 1);
            indice_eserie_p_hasta = variable.entrega_varopt_operacion('P', 2);

            bus1 = variable.entrega_bus1();
            indice_eq_bus1_desde = bus1.entrega_indice_restriccion_balance_energia(1);
            indice_eq_bus1_hasta = bus1.entrega_indice_restriccion_balance_energia(2);
            bus2 = variable.entrega_bus2();
            indice_eq_bus2_desde = bus2.entrega_indice_restriccion_balance_energia(1);
            indice_eq_bus2_hasta = bus2.entrega_indice_restriccion_balance_energia(2);

            this.Aeq(indice_eq_bus1_desde:indice_eq_bus1_hasta,indice_eserie_p_desde:indice_eserie_p_hasta) = this.Aeq(indice_eq_bus1_desde:indice_eq_bus1_hasta,indice_eserie_p_desde:indice_eserie_p_hasta) + diag(ones(cant_po,1))*-1;
            this.Aeq(indice_eq_bus2_desde:indice_eq_bus2_hasta,indice_eserie_p_desde:indice_eserie_p_hasta) = this.Aeq(indice_eq_bus2_desde:indice_eq_bus2_hasta,indice_eserie_p_desde:indice_eserie_p_hasta) + diag(ones(cant_po,1));
            %for oper = 1:length(this.vPuntosOperacion)
            %    this.Aeq(indice_eq_bus1_desde + oper - 1,indice_eserie_p_desde + oper - 1) = -1;
            %    this.Aeq(indice_eq_bus2_desde + oper - 1,indice_eserie_p) = 1;
            %end
        end
        
        function agrega_balance_energia(this, bus)
            % Función sólo para utilizar con TNEP.
            cant_po = length(this.vPuntosOperacion);
            indice_eq_desde = this.iIndiceEq +1;
            indice_eq_hasta = this.iIndiceEq + cant_po;
            this.iIndiceEq = this.iIndiceEq +cant_po;
            
            bus.agrega_indice_restriccion_balance_energia(1, indice_eq_desde);
            bus.agrega_indice_restriccion_balance_energia(2, indice_eq_hasta);
            this.Aeq = [this.Aeq; zeros(cant_po,length(this.Fobj))];
            % Balance de potencia activa en bus
            %generadores
            pGeneradores = bus.entrega_generadores_despachables();
            if ~isempty(pGeneradores)
                error = MException('cOPF:agrega_balance_energia','Error de programación. Función no acepta generadores en nuevos buses');
                throw(error)
            end
                    
            elpar = bus.entrega_elementos_paralelos();
            if ~isempty(elpar)
                error = MException('cOPF:agrega_balance_energia','Error de programación. Función no acepta elementos paralelos en nuevos buses');
                throw(error)
            end
            this.beq(indice_eq_desde:indice_eq_hasta) = 0;
                
            pConsumos = bus.entrega_consumos();
            if ~isempty(pConsumos)
                error = MException('cOPF:agrega_balance_energia','Error de programación. Función no acepta consumos en nuevos buses');
                throw(error)
            end
            
            % elementos serie
            eserie = bus.entrega_elementos_serie();
            if ~isempty(eserie)
                error = MException('cOPF:agrega_balance_energia','Error de programación. Bus se acaba de agregar como variable independiente, por lo que aún no debiera tener elementos en serie conectados');
                throw(error)
            end
            
            if this.iNivelDebug > 0
                for oper = 1:cant_po
                    this.NombreEq{indice_eq_desde + oper - 1} = strcat('req_', num2str(indice_eq_desde + oper - 1), '_be_', 'B', num2str(bus.entrega_id_global()), '_O', num2str(oper));
                end
            end
        end

        
        function escribe_relaciones_flujos_angulos(this)
            cant_po = length(this.vPuntosOperacion);
            eserie = this.pSM.entrega_elementos_serie();
            for i = 1:length(eserie)
                indice_eq_desde = this.iIndiceEq +1;
                indice_eq_hasta = this.iIndiceEq + cant_po;
                this.iIndiceEq = this.iIndiceEq +cant_po;
            
                eserie(i).agrega_indice_restriccion_flujos_angulos(1, indice_eq_desde);
                eserie(i).agrega_indice_restriccion_flujos_angulos(2, indice_eq_hasta);
                
                id_eserie_desde = eserie(i).entrega_varopt_operacion('P', 1);
                id_eserie_hasta = eserie(i).entrega_varopt_operacion('P', 2);
                
                bus1 = eserie(i).entrega_bus1();
                bus2 = eserie(i).entrega_bus2();
                id_t1_desde = bus1.entrega_varopt_operacion('Theta', 1);
                id_t1_hasta = bus1.entrega_varopt_operacion('Theta', 2);
                id_t2_desde = bus2.entrega_varopt_operacion('Theta', 1);
                id_t2_hasta = bus2.entrega_varopt_operacion('Theta', 2);
                
                x = round(eserie(i).entrega_reactancia(),5);
                
                this.Aeq(indice_eq_desde:indice_eq_hasta,id_eserie_desde:id_eserie_hasta) = this.Aeq(indice_eq_desde:indice_eq_hasta,id_eserie_desde:id_eserie_hasta) + diag(ones(cant_po,1))*x;
                this.Aeq(indice_eq_desde:indice_eq_hasta,id_t1_desde:id_t1_hasta) = this.Aeq(indice_eq_desde:indice_eq_hasta,id_t1_desde:id_t1_hasta) + diag(ones(cant_po,1))*-1;
                this.Aeq(indice_eq_desde:indice_eq_hasta,id_t2_desde:id_t2_hasta) = this.Aeq(indice_eq_desde:indice_eq_hasta,id_t2_desde:id_t2_hasta) + diag(ones(cant_po,1));
                %for oper = 1:cant_po
                %    this.Aeq(indice_eq_desde + oper - 1,id_eserie_desde + oper - 1) = x;
                %    this.Aeq(indice_eq_desde + oper - 1,id_t1_desde + oper - 1) = -1;
                %    this.Aeq(indice_eq_desde + oper - 1,id_t2_desde + oper - 1) = 1;
                %end
                this.beq(indice_eq_desde:indice_eq_hasta) = 0;
                
                if this.pParOpt.entrega_flujo_dc_con_perdidas()
                    % se agregan las pérdidas. Aún no está implementado
                    % porque introduce relaciones cuadráticas con los
                    % ángulos
                    % fórmula: r/(2x^2)*(t1-t2)^2
                    r = eserie(i).entrega_resistencia();
                    factor = r/(2*x^2);
                    error = MException('cDCOPF:escribe_relaciones_flujos_angulos','OPF DC con pérdidas aún no implementado');
                    throw(error)
                end
                
                if this.iNivelDebug > 0
                    id_par = eserie(i).entrega_elemento_red().entrega_indice_paralelo();
                    if isa(eserie(i).entrega_elemento_red(), 'cLinea')
                        texto = 'L';
                    else
                        texto = 'Tr';
                    end
                    for oper = 1:cant_po
                        this.NombreEq{indice_eq_desde + oper - 1} = strcat('req_', num2str(indice_eq_desde + oper - 1), '_flujos_angulos', texto, num2str(id_par), ...
                            '_B', num2str(bus1.entrega_id_global()), '_', num2str(bus2.entrega_id_global()), '_O', num2str(oper));
                    end
                end
            end
        end

        function agrega_relaciones_flujos_angulos(this, variable)
            cant_po = length(this.vPuntosOperacion);
            indice_eq_desde = this.iIndiceEq +1;
            indice_eq_hasta = this.iIndiceEq + cant_po;
            this.iIndiceEq = this.iIndiceEq +cant_po;
            
            variable.agrega_indice_restriccion_flujos_angulos(1, indice_eq_desde);
            variable.agrega_indice_restriccion_flujos_angulos(2, indice_eq_hasta);
            
            id_eserie_desde = variable.entrega_varopt_operacion('P', 1);
            id_eserie_hasta = variable.entrega_varopt_operacion('P', 2);
            bus1 = variable.entrega_bus1();
            bus2 = variable.entrega_bus2();
            id_t1_desde = bus1.entrega_varopt_operacion('Theta', 1);
            id_t1_hasta = bus1.entrega_varopt_operacion('Theta', 2);
            id_t2_desde = bus2.entrega_varopt_operacion('Theta', 1);
            id_t2_hasta = bus2.entrega_varopt_operacion('Theta', 2);
                
            x = round(variable.entrega_reactancia(),5);
            this.Aeq = [this.Aeq; zeros(cant_po, length(this.Fobj))];
            this.Aeq(indice_eq_desde:indice_eq_hasta,id_eserie_desde:id_eserie_hasta) = this.Aeq(indice_eq_desde:indice_eq_hasta,id_eserie_desde:id_eserie_hasta) + diag(ones(cant_po,1))*x;
            this.Aeq(indice_eq_desde:indice_eq_hasta,id_t1_desde:id_t1_hasta) = this.Aeq(indice_eq_desde:indice_eq_hasta,id_t1_desde:id_t1_hasta) + diag(ones(cant_po,1))*-1;
            this.Aeq(indice_eq_desde:indice_eq_hasta,id_t2_desde:id_t2_hasta) = this.Aeq(indice_eq_desde:indice_eq_hasta,id_t2_desde:id_t2_hasta) + diag(ones(cant_po,1));
            
            %for oper = 1:cant_po
            %    this.Aeq(indice_eq_desde + oper - 1,id_eserie_desde + oper - 1) = x;
            %    this.Aeq(indice_eq_desde + oper - 1,id_t1_desde + oper - 1) = -1;
            %    this.Aeq(indice_eq_desde + oper - 1,id_t2_desde + oper - 1) = 1;
            %end
            this.beq(indice_eq_desde:indice_eq_hasta) = 0;
                
            if this.pParOpt.entrega_flujo_dc_con_perdidas()
                error = MException('cDCOPF:agrega_relaciones_flujos_angulos','OPF DC con pérdidas aún no implementado');
                throw(error)
            end
                
            if this.iNivelDebug > 0
            	id_par = variable.entrega_elemento_red().entrega_indice_paralelo();
                if isa(variable.entrega_elemento_red(), 'cLinea')
                    texto = 'L';
                else
                    texto = 'Tr';
                end
                for oper = 1:cant_po
                    this.NombreEq{indice_eq_desde + oper - 1} = strcat('req_', num2str(indice_eq_desde + oper - 1), '_flujos_angulos', texto, num2str(id_par), ...
                        '_B', num2str(bus1.entrega_id_global()), '_', num2str(bus2.entrega_id_global()), '_O', num2str(oper));
                end
            end
        end
        
        function optimiza(this)
            if this.pParOpt.entrega_flujo_dc_con_perdidas()
                error = MException('cDCOPF:optimiza','OPF DC con pérdidas aún no implementado');
                throw(error)
            else
                if this.iNivelDebug > 1
                    prot = cProtocolo.getInstance;
                    prot.imprime_texto('Comienzo proceso optimizacion OPF DC');
                    if this.iNivelDebug > 2
                        prot.imprime_texto('Dimensiones del problema:');
                        prot.imprime_texto(strcat('Cantidad de variables de decision: ', num2str(length(this.VarOpt))));
                        prot.imprime_texto(strcat('Dimension de funcion objetivo: ', num2str(length(this.Fobj))));
                        [m, n] = size(this.Aineq);
                        prot.imprime_texto(strcat('Dimension matriz de desigualdad: ', num2str(m), 'x', num2str(n)));
                        prot.imprime_texto(strcat('Dimension vector de desigualdad: ', num2str(length(this.bineq))));
                        prot.imprime_texto(strcat('Cantidad desigualdades: ', num2str(this.iIndiceIneq)));
                        [m, n] = size(this.Aeq);
                        prot.imprime_texto(strcat('Dimension matriz de igualdad: ', num2str(m), 'x', num2str(n)));
                        prot.imprime_texto(strcat('Dimension vector de igualdad: ', num2str(length(this.beq))));
                        prot.imprime_texto(strcat('Cantidad igualdades: ', num2str(this.iIndiceEq)));
                        prot.imprime_texto(strcat('Dimension vector lb: ', num2str(length(this.lb))));
                        prot.imprime_texto(strcat('Dimension vector ub: ', num2str(length(this.ub))));
                    end
                end
                if strcmp(this.pParOpt.Solver, 'Intlinprog')
                    if this.iNivelDebug > 0
                        if this.iNivelDebug > 1
                            options = optimoptions('linprog','Display','iter');
                        else
                            options = optimoptions('linprog','Display','final');
                        end
                    else
                        options = optimoptions('linprog','Display','off');
                    end
                
                    if this.MuestraDetalleIteraciones
                        % fuerza mostrar el detalle de las iteraciones,
                        % independiente del nivel de debug
                        options = optimoptions('linprog','Display','iter');
                    end
                    
                    [this.ResOptimizacion, this.Fval,this.ExitFlag,this.Output,this.Lambda]= linprog(this.Fobj,this.Aineq,this.bineq,this.Aeq,this.beq,this.lb,this.ub, [], options);
                elseif strcmp(this.pParOpt.Solver, 'Xpress')
                    options = xprsoptimset(optimset('Display', 'off'));
                    if this.MuestraDetalleIteraciones
                        options = xprsoptimset(optimset('Display', 'iter'));
                    end
                    rtype = [repmat('L',[1 size(this.Aineq,1)]) repmat('E',[1 size(this.Aeq,1)])];
                    [this.ResOptimizacion,this.Fval,this.ExitFlag,this.Output] = xprslp(this.Fobj,[this.Aineq; this.Aeq], [this.bineq; this.beq], rtype, this.lb,this.ub, options);%, options);
                	
                else
                    error = MException('cDCOPF:optimiza',...
                                       ['Optimizador "' this.pParOpt.Solver ' no está implementado']);
                    throw(error)    
                end
                %redondea resultados
                this.ResOptimizacion = round(this.ResOptimizacion,5);
            end
        end
        
		function escribe_resultados(this)
            %primero una función de chequeo
            sbase = cParametrosSistemaElectricoPotencia.getInstance.entrega_sbase();
            buses = this.pSM.entrega_buses();
            cant_po = length(this.vPuntosOperacion);
            for bus = 1:length(buses)
                %ángulo del bus
                se = buses(bus).entrega_elemento_red();
                id_se = se.entrega_id();
                indice_opt_desde = buses(bus).entrega_varopt_operacion('Theta', 1);
                indice_opt_hasta = buses(bus).entrega_varopt_operacion('Theta', 2);
                
                theta = this.ResOptimizacion(indice_opt_desde:indice_opt_hasta);                                    
                this.pResEvaluacion.AnguloSubestaciones(id_se, 1:cant_po) = theta'/pi*180;

                %generadores
                generadores = buses(bus).entrega_generadores_despachables();
                for gen = 1:length(generadores)
                    el_red = generadores(gen).entrega_elemento_red();                        
                    id_gen = el_red.entrega_id_resultado_evaluacion();
                    costo_mwh = el_red.entrega_costo_mwh();
                    indice_opt_desde = generadores(gen).entrega_varopt_operacion('P', 1);
                    indice_opt_hasta = generadores(gen).entrega_varopt_operacion('P', 2);
                    p_mw = this.ResOptimizacion(indice_opt_desde:indice_opt_hasta)*sbase;
                    if strcmp(this.pParOpt.entrega_tipo_problema(), 'Redespacho')
                        this.pResEvaluacion.CostoRedespacho = this.pResEvaluacion.CostoRedespacho + costo_mwh * p_mw;
                        p0 = el_red.entrega_p0();
                        p_mw = p_mw + p0;
                    end
                    this.pResEvaluacion.GeneradoresDespachablesP(id_gen, :) = p_mw';
                    this.pResEvaluacion.CostoGeneracion = this.pResEvaluacion.CostoGeneracion + costo_mwh*p_mw;
                end

                %consumos                    
                consumos = buses(bus).entrega_consumos();
                for con = 1:length(consumos)
                    elred = consumos(con).entrega_elemento_red();
                    id_elred = elred.entrega_id();

                    if this.pParOpt.considera_desprendimiento_carga()
                        indice_opt_desde = consumos(con).entrega_varopt_operacion('P', 1);
                        indice_opt_hasta = consumos(con).entrega_varopt_operacion('P', 2);
                        ens = this.ResOptimizacion(indice_opt_desde:indice_opt_hasta)*sbase;
                        this.pResEvaluacion.ENSConsumos(id_elred, :) = ens';
                    else
                        ens = 0;
                    end
                    if this.DatosEscenarioLocal
                        id_consumo_sc = elred.entrega_indice_escenario();
                        p0 = this.SerieConsumos(id_consumo_sc, :);                            
                    elseif ~isempty(this.pAdmSc)
                        % factor de expansión para TNEP
                        id_consumo_sc = elred.entrega_indice_escenario();
                        
                        desde = (this.iEtapa-1)*cant_po + 1;
                        hasta = this.iEtapa*cant_po;
                        
                        p0 = this.pAdmSc.SerieConsumos(id_consumo_sc, desde:hasta);
                    else
                        % sólo un punto de operación
                        p0 = -elred.entrega_p_const_nom(); %p0 tiene valor positivo
                    end

                    this.pResEvaluacion.ConsumosP(id_elred, :) = p0-ens';
                    if sum(ens) > 0
                        costo_desconexion = elred.entrega_costo_desconexion_carga();
                        costo_ens = ens*costo_desconexion;
                        this.pResEvaluacion.CostoENS = this.pResEvaluacion.CostoENS + costo_ens;
                    end
                end

                generadores_ernc = buses(bus).entrega_generadores_ernc();
                for gen = 1:length(generadores_ernc)
                    el_red = generadores_ernc(gen).entrega_elemento_red();                        
                    id_gen = el_red.entrega_id_resultado_evaluacion();
                    id_generador_sc = el_red.entrega_indice_escenario();
                    if this.DatosEscenarioLocal
                        pnom = this.SerieGeneradoresERNC(id_generador_sc, :);
                    elseif ~isempty(this.pAdmSc)
                        desde = 1+ (this.iEtapa - 1)*cant_po;
                        hasta = this.iEtapa*cant_po;
                        pnom = this.pAdmSc.SerieGeneradoresERNC(id_generador_sc, desde:hasta);                        
                    else
                        % sólo un punto de operación
                        pnom = elred.entrega_pmax_pu();
                    end
                    p_mw_recorte = zeros(cant_po,1);
                    if this.pParOpt.ConsideraRecorteRES
                        indice_opt_desde = generadores_ernc(gen).entrega_varopt_operacion('P', 1);
                        indice_opt_hasta = generadores_ernc(gen).entrega_varopt_operacion('P', 2);
                        p_mw_recorte = this.ResOptimizacion(indice_opt_desde:indice_opt_hasta)*sbase;
                        this.pResEvaluacion.RecorteGeneradoresRES(id_gen, :) = p_mw_recorte';
                        if sum(p_mw_recorte) > 0
                            penalizacion = this.pParOpt.entrega_penalizacion_recorte_res(); % en $/MWh
                            costo_recorte = p_mw_recorte*penalizacion;
                            this.pResEvaluacion.CostoRecorteGeneradoresRES = this.pResEvaluacion.CostoRecorteGeneradoresRES + costo_recorte;
                        end
                    end
                    this.pResEvaluacion.GeneradoresRESP(id_gen, :) = pnom - p_mw_recorte';
                end

                %lineas y trafos
                eserie = buses(bus).entrega_elementos_serie();
                for j = 1:length(eserie)                    
                    bus1 = eserie(j).entrega_bus1();
                    if bus1 ~= buses(bus)
                        %Sólo para bus inicial para no repetir
                        continue;
                    end
                    indice_opt_desde = eserie(j).entrega_varopt_operacion('P', 1);
                    indice_opt_hasta = eserie(j).entrega_varopt_operacion('P', 2);
                    elred = eserie(j).entrega_elemento_red();
                    sr = elred.entrega_sr();
                    flujo_p = this.ResOptimizacion(indice_opt_desde:indice_opt_hasta)*sbase;
                    porcentaje_uso = abs(flujo_p)/sr;
                    id_elred = elred.entrega_id();
                    if isa(elred, 'cLinea')
                        this.pResEvaluacion.FlujoLineasP(id_elred, :) = flujo_p';
                        if elred.tiene_flag_observacion()
                            if min(porcentaje_uso) > this.pParOpt.PorcentajeUsoFlujosAltos
                                this.pResEvaluacion.inserta_linea_flujo_maximo(elred, max(porcentaje_uso));
                            elseif max(porcentaje_uso) < this.pParOpt.PorcentajeUsoFlujosBajos % bajo flujo
                                this.pResEvaluacion.inserta_linea_poco_uso(elred, min(porcentaje_uso));
                            end
                        end
                    elseif  isa(elred, 'cTransformador2D')
                        this.pResEvaluacion.FlujoTransformadoresP(id_elred, :) = flujo_p';
                        if elred.tiene_flag_observacion()
                            if min(porcentaje_uso) > this.pParOpt.PorcentajeUsoFlujosAltos % flujo por trafo mayor al 95%
                                this.pResEvaluacion.inserta_trafo_flujo_maximo(elred, max(porcentaje_uso));
                            elseif max(porcentaje_uso) < this.pParOpt.PorcentajeUsoFlujosBajos % bajo flujo
                                this.pResEvaluacion.inserta_trafo_poco_uso(elred, min(porcentaje_uso));
                            end
                        end
                    else
                        error = MException('cDCOPF:escribe_resultados',...
                                ['Tipo elemento (' class(elred) ' aún no implementado']);
                        throw(error)
                    end
                end % fin elementos serie
            end %fin buses
            
            if this.InsertaResultadosEnSEP
                this.pResEvaluacion.inserta_resultados_en_sep();
            end
        end

        function imprime_resultados_protocolo(this)
            prot = cProtocolo.getInstance;
            sbase = cParametrosSistemaElectricoPotencia.getInstance.entrega_sbase();
            if this.iNivelDebug > 1
                prot.imprime_texto('');
                prot.imprime_texto('Resultados DC-OPF');
                prot.imprime_texto('Resultado variables optimizacion');
                for i = 1:length(this.ResOptimizacion)
                    texto = sprintf('%10s %5s %35s %3s %10s %5s %10s ', ...
                        num2str(this.lb(i)), '<=', this.NombreVariables{i}, '=', ...
                        num2str(this.ResOptimizacion(i)), '<=', num2str(this.ub(i)));
                    prot.imprime_texto(texto);
                end
            end
            
            for oper = 1:length(this.vPuntosOperacion)
                prot.imprime_texto(['PO: ' num2str(oper)]);
                prot.imprime_texto('Balance de energia');
                texto = sprintf('%-15s %-15s %-10s %-15s %-10s %-10s %-10s %-10s', 'Subestacion', 'Generacion', 'Consumo', 'ENS','Recorte RES', 'Pin', 'Pout', 'Balance');
                prot.imprime_texto(texto);
                buses = this.pSM.entrega_buses();
                for bus = 1:length(buses)
                	suma_gen = 0;
                    suma_capacidad_gen = 0;
                    generadores = buses(bus).entrega_generadores_despachables();
                    for gen = 1:length(generadores)
                        el_red = generadores(gen).entrega_elemento_red();
                        indice_opt = generadores(gen).entrega_varopt_operacion('P', 1) + oper - 1;
                        p_mw = this.ResOptimizacion(indice_opt)*sbase;
                        if strcmp(this.pParOpt.entrega_tipo_problema(), 'Redespacho')
                            p0 = el_red.entrega_p0();
                            p_mw = p_mw + p0;
                        end
                        if this.DatosEscenarioLocal
                            id_generador_sc = el_red.entrega_indice_escenario();
                            pmax = this.CapacidadGeneradores(id_generador_sc);
                        elseif ~isempty(this.pAdmSc)
                        	% factor de expansión para TNEP
                            id_generador_sc = el_red.entrega_indice_escenario();
                            pmax = this.pAdmSc.entrega_capacidad_generador(id_generador_sc, this.iEtapa);
                        else
                            pmax = elred.entrega_pmax();
                        end
                        suma_capacidad_gen = suma_capacidad_gen + pmax;
                        suma_gen = suma_gen + p_mw;
                    end
                    
                    % generadores RES
                    p_mw_recorte_total = 0;
                    generadores_ernc = buses(bus).entrega_generadores_ernc();
                    for gen = 1:length(generadores_ernc)
                        el_red = generadores_ernc(gen).entrega_elemento_red();
                        id_generador_sc = el_red.entrega_indice_escenario();
                        if this.DatosEscenarioLocal
                            pnom = this.SerieGeneradoresERNC(id_generador_sc, oper);
                        elseif ~isempty(this.pAdmSc)
                            pnom = this.pAdmSc.entrega_inyeccion(id_generador_sc, this.iEtapa, oper);
                        else
                            pnom = elred.entrega_pmax_pu();
                        end
                        p_mw_recorte = 0;
                        if this.pParOpt.ConsideraRecorteRES
                            indice_opt = generadores_ernc(gen).entrega_varopt_operacion('P', 1) + oper - 1;
                            p_mw_recorte = this.ResOptimizacion(indice_opt)*sbase;
                            p_mw_recorte_total = p_mw_recorte_total + p_mw_recorte;
                        end
                        suma_capacidad_gen = suma_capacidad_gen + pnom;
                        suma_gen = suma_gen + pnom - p_mw_recorte;
                    end
                                        
                    %consumos
                    p_consumo = 0;
                    p_ens = 0;
                    consumos = buses(bus).entrega_consumos();
                    for con = 1:length(consumos)
                        elred = consumos(con).entrega_elemento_red();

                        if this.pParOpt.considera_desprendimiento_carga()
                            indice_opt = consumos(con).entrega_varopt_operacion('P', 1) + oper - 1;
                            ens = this.ResOptimizacion(indice_opt)*sbase;
                        else
                            ens = 0;
                        end
                        if this.DatosEscenarioLocal
                            id_consumo_sc = elred.entrega_indice_escenario();
                            p0 = this.SerieConsumos(id_consumo_sc, oper);
                        elseif ~isempty(this.pAdmSc)
                        	% factor de expansión para TNEP
                            id_consumo_sc = elred.entrega_indice_escenario();
                            p0 = this.pAdmSc.entrega_consumo(id_consumo_sc, this.iEtapa, oper);
                        else
                            p0 = -elred.entrega_p_const_nom(); %p0 tiene valor positivo
                        end

                        p_consumo = p_consumo + p0-ens;
                        p_ens = p_ens + ens;
                    end
                    
                    %lineas y trafos
                    pin = 0;
                    pout = 0;
                    eserie = buses(bus).entrega_elementos_serie();
                    for j = 1:length(eserie)                    
                        bus1 = eserie(j).entrega_bus1();
                        if bus1 == buses(bus)
                            signo = -1;
                        else
                            signo = 1;
                        end
                        
                        indice_opt = eserie(j).entrega_varopt_operacion('P', 1) + oper - 1;
                        flujo_p = this.ResOptimizacion(indice_opt)*sbase;
                        if signo*flujo_p < 0
                        	pout = pout - signo*flujo_p;
                        else
                        	pin = pin + signo*flujo_p;
                        end                        
                    end % fin elementos serie
                        
                    texto_generacion = [num2str(suma_gen) '/' num2str(suma_capacidad_gen)];
                    texto = sprintf('%-15s %-15s %-10s %-15s %-10s %-10s %-10s %-10s', buses(bus).entrega_elemento_red().entrega_nombre(), ...
                    	texto_generacion,...
                        num2str(round(p_consumo,5)),...
                        num2str(round(p_ens,5)),...
                        num2str(round(p_mw_recorte_total,5)),...
                        num2str(round(pin,5)),...
                        num2str(round(pout,5)),...
                        num2str(round(suma_gen-p_consumo++p_ens+pin-pout,5)));
                    prot.imprime_texto(texto);
                end %fin buses
                
                % ahora se imprimen los resultados por subestación detallando
                % las líneas/trafos
                prot.imprime_texto('');
                prot.imprime_texto('Detalle de flujos por subestacion');
                texto = sprintf('%-25s %-15s %-15s %-7s %-8s %-8s %-8s %-8s %-8s %-8s %-25s', ...
                        'Linea', 'SE1', 'SE2', 'Signo', 'T1grad', 'T2grad', 'T1-T2', 'Xel', 'PMW', 'Pmax', 'Dif.calculado');
                prot.imprime_texto(texto);
                for bus1 = 1:length(buses)
                    eserie = buses(bus1).entrega_elementos_serie();
                    for bus2 = bus1+1:length(buses)
                        for j = 1:length(eserie)
                            bus_inicial = eserie(j).entrega_bus1();
                            bus_final = eserie(j).entrega_bus2();
                            
                            if bus_inicial ~= buses(bus2) && bus_final ~= buses(bus2)
                                continue;
                            end
                                indice_eserie_p = eserie(j).entrega_varopt_operacion('P', 1) + oper - 1;
                                p_serie = this.ResOptimizacion(indice_eserie_p)*sbase;
                                sr = eserie(j).entrega_elemento_red().entrega_sr();
                                
                            	indice_bus1 = buses(bus1).entrega_varopt_operacion('Theta', 1) + oper - 1;
                                t1 = this.ResOptimizacion(indice_bus1);
                                indice_bus2 = buses(bus2).entrega_varopt_operacion('Theta', 1) + oper - 1;
                                t2 = this.ResOptimizacion(indice_bus2);

                                if bus_inicial == buses(bus1)
                                    signo = 1; % linea va de SE1 a SE2 por lo que flujo sale de la subestacion
                                else
                                    signo = -1;
                                end
                                x = eserie(j).entrega_reactancia();
                                angulo_1 = round(t1/pi*180,1);
                                angulo_2 = round(t2/pi*180,1);
                                        
                                diff_angulo = round((t1-t2)/pi*180,1);
                                diff_calculado = signo*(t1-t2)/x*sbase;
                                diff_calculado = diff_calculado-p_serie;
                                texto = sprintf('%-25s %-15s %-15s %-7s %-8s %-8s %-8s %-8s %-8s %-8s %-25s', ...
                                        eserie(j).entrega_elemento_red().entrega_nombre(), ...
                                        buses(bus1).entrega_elemento_red().entrega_nombre(), ...
                                        buses(bus2).entrega_elemento_red().entrega_nombre(), ...
                                        num2str(signo), ...
                                        num2str(angulo_1), ...
                                        num2str(angulo_2), ...
                                        num2str(diff_angulo), ...
                                        num2str(round(x,3)), ...
                                        num2str(round(p_serie,3)), ...
                                        num2str(round(sr,3)), ...
                                        num2str(round(diff_calculado,2)));
                                    prot.imprime_texto(texto);
                        end
                    end %fin subestaciones
                end % fin puntos de operación
            end
        end
        
        function evaluacion = entrega_evaluacion(this)
            evaluacion = this.pResEvaluacion;
        end
        
        function imprime_problema_optimizacion(this, varargin)
            % varargin indica el nombre del documento donde se quiere
            % imprimir. Si no se indica nada, entonces lo imprime con un
            % nombre predeterminado
            % sólo en modo debug. imprime el problema en archivo externo
            % determina nombre de variables de optimización
            % esto se hace sólo aquí, para no afectar la performance del
            % programa con datos que no se necesitan
            %[NombreIneq, NombreEq] = this.escribe_nombre_restricciones();
            
            %cantidad_var_decision = length(this.vPuntosOperacion) * (length(this.pSEP.GeneradoresDespachables) + ...
            %    length(this.pSEP.Subestaciones) + 3*length(this.pSEP.Lineas));

            if nargin > 1
                nombre_documento = varargin{1};
            else
                nombre_documento = [this.nombre_archivo_problema_opt '_' this.caso_estudio '_' num2str(this.iEtapa)];
            end
            docID = fopen(nombre_documento,'w');
            fprintf(docID, 'Formulacion matematica OPF\n');
            fprintf(docID, ['Tipo problema : ' this.pParOpt.entrega_tipo_problema()]);
            fprintf(docID, ['\nFuncion objetivo: ' this.pParOpt.entrega_funcion_objetivo()]);
            fprintf(docID, ['\nTipo flujo de potencia: ' this.pParOpt.entrega_tipo_flujo()]);
            fprintf(docID, ['\nTipo restricciones seguridad: ' this.pParOpt.entrega_tipo_restricciones_seguridad()]);
            if this.pParOpt.entrega_flujo_dc_con_perdidas()
            	val = 'si';
            else
            	val = 'no';
            end
                fprintf(docID, ['\nConsidera pérdidas: ' val]);
            fprintf(docID, '\n');
            
            fprintf(docID, 'Funcion objetivo\n');
            primero = true;
            for i = 1:length(this.Fobj)
                if this.Fobj(i) ~= 0
                    val = round(this.Fobj(i),3);                    
                    if primero
                        text = strcat(num2str(val),'(',this.NombreVariables{i},')');
                        primero = false;
                    else
                        if this.Fobj(i) > 0
                            text = strcat(text, ' + ',num2str(val),'(', this.NombreVariables{i},')');
                        else
                            text = strcat(text, ' - ',num2str(abs(val)),'(',this.NombreVariables{i},')');
                        end
                        if length(text) > 170
                            text = strcat(text,'\n');
                            fprintf(docID, text);
                            primero = true;
                        end
                    end
                end
            end
            text = strcat(text,'\n');
            fprintf(docID, text);
            % restricciones
            % restricciones de desigualdad
            if ~isempty(this.bineq)
                fprintf(docID, 'Restricciones de desigualdad:\n');
            end
            
            for i = 1:length(this.bineq)    
                nombre_ineq = this.NombreIneq{i};
                fprintf(docID, strcat(nombre_ineq,':\n'));
                primero = true;
                for j = 1:length(this.VarOpt)
                    if this.Aineq(i,j) ~= 0
                        val = this.Aineq(i,j);                    
                        if primero
                            if val == 1
                                text = strcat('(',this.NombreVariables{j},')');
                            elseif val == -1
                                text = strcat('-', '(' ,this.NombreVariables{j}, ')');
                            else
                                text = strcat(num2str(val), '(', this.NombreVariables{j}, ')');
                                %error = MException('cMILPOpt:imprime_problema_optimizacion','valor restriccion de desigualdad debe ser 1 o -1');
                                %throw(error)
                            end
                            primero = false;
                        else
                            if val == 1
                                text = strcat(text, ' + ', '(', this.NombreVariables{j}, ')');
                            elseif val == -1
                                text = strcat(text, ' - ', '(', this.NombreVariables{j}, ')');
                            elseif val > 0
                                text = strcat(text, ' + ', num2str(val), '(', this.NombreVariables{j}, ')');
                            else
                                text = strcat(text, ' - ', num2str(abs(val)), '(', this.NombreVariables{j}, ')');
                                %error = MException('cMILPOpt:imprime_problema_optimizacion','valor restriccion de desigualdad debe ser 1 o -1');
                                %throw(error)
                            end
                            if length(text) > 170
                                text = strcat(text,'\n');
                                fprintf(docID, text);
                                primero = true;
                            end
                        end
                    end
                end
                text = strcat(text,' <= ', num2str(this.bineq(i)),'\n\n');
                fprintf(docID, text);
            end

            fprintf(docID, 'Restricciones de igualdad:\n');
            for i = 1:length(this.beq)
                nombre_eq = this.NombreEq{i};

                fprintf(docID, strcat(nombre_eq,':\n'));
                primero = true;
                [~, id] = find(this.Aeq(i,:));
                if isempty(id)
                    error = MException('cDCOPF:imprime_problema_optimizacion',...
                                       ['Inconsistencia en los datos. Ecuación de igualdad ' nombre_eq ' no tiene variables activas']);
                    throw(error)
                end
                
                for kk = 1:length(id)
                    id_var = id(kk);
                    val = this.Aeq(i,id_var);
                    if primero
                        if val == 1
                            text = strcat(this.NombreVariables{id_var});
                        elseif val == -1
                            text = strcat('-',this.NombreVariables{id_var});
                        elseif val > 0
                            text = strcat(num2str(round(val,3)),'*',this.NombreVariables{id_var});
                        else
                            text = strcat('-', num2str(abs(round(val,3))),'*',this.NombreVariables{id_var});
                        end
                        primero = false;
                    else
                        if val == 1
                            text = strcat(text, ' + ',this.NombreVariables{id_var});
                        elseif val == -1
                            text = strcat(text, ' - ',this.NombreVariables{id_var});
                        elseif val > 0
                            text = strcat(text, ' + ', num2str(round(val,3)),'*',this.NombreVariables{id_var});
                        else
                            text = strcat(text, ' - ', num2str(abs(round(val,3))),'*',this.NombreVariables{id_var});
                        end
                        if length(text) > 170
                            text = strcat(text,'\n');
                            fprintf(docID, text);
                            primero = true;
                        end
                    end
                end
                text = strcat(text,' = ', num2str(this.beq(i)),'\n\n');
                fprintf(docID, text);
            end
            
            % límites de las variables
            fprintf(docID, 'Limites variables de decision:\n');
            for i = 1:length(this.Fobj)
                text = strcat(num2str(this.lb(i)), ' <= ', this.NombreVariables{i}, ' <= ', num2str(this.ub(i)), '\n');
                fprintf(docID, text);
            end
            fprintf(docID, 'fin');
            fclose(docID);
        end
        
        function inserta_varopt(this, vector, tipo_variable, unidades)
            if ~isempty(vector)
                pos = length(this.VarOpt);
                this.VarOpt = [this.VarOpt; vector];
                for i = 1:length(vector)
                    vector(i).inserta_indice_varopt(pos + i);
                    this.TipoVarOpt{end+1} = tipo_variable;
                    this.UnidadesVarOpt{end+1} = unidades;
                end
            end
        end

        function agrega_varopt(this, variable, tipo_variable, unidades)
            this.VarOpt = [this.VarOpt; variable];
            id = length(this.VarOpt);
            variable.inserta_indice_varopt(id);
            this.TipoVarOpt{id} = tipo_variable;
            this.UnidadesVarOpt{id} = unidades;
        end
        
        function ingresa_nombres(this, indice_varopt, indice_global_desde, tipo_varopt, unidades_varopt)
            switch tipo_varopt
                case 'VariableControl'
                    if strcmp(unidades_varopt, 'P')
                        % Se trata de un generador
                        id_bus = this.VarOpt(indice_varopt).entrega_bus().entrega_id_global();
                        for oper = 1:length(this.vPuntosOperacion)
                            indice_nombre = indice_global_desde + oper -1;
                            texto = strcat('P_G', num2str(this.VarOpt(indice_varopt).entrega_elemento_red().entrega_id()), ...
                                           '_B', num2str(id_bus), '_O', num2str(oper));
                            this.NombreVariables{indice_nombre} = texto;
                        end
                    else
                        error = MException('cOPF:ingresa_nombres',...
                                           ['Inconsistencia en los datos. Tipo de variable unidad en variable de control '...
                                             unidades_varopt ' no implementada']);
                        throw(error)
                    end
                case 'VariableEstado'
                    if strcmp(unidades_varopt, 'Theta')
                        id_bus = this.VarOpt(indice_varopt).entrega_id_global();
                        for oper = 1:length(this.vPuntosOperacion)
                            indice_nombre = indice_global_desde + oper -1;
                            texto = strcat('Theta_B', num2str(id_bus), ...
                                           '_O', num2str(oper));
                            this.NombreVariables{indice_nombre} = texto;
                        end
                    else
                        error = MException('cOPF:ingresa_nombres',...
                                           ['Inconsistencia en los datos. Tipo de variable unidad en variable de estado '...
                                             unidades_varopt ' no implementada']);
                        throw(error)
                    end
                case 'VariableAuxiliar'
                    if strcmp(unidades_varopt, 'P')
                        % Potencia activa en una línea o un trafo o consumo
                        elred = this.VarOpt(indice_varopt).entrega_elemento_red();
                        if isa(elred, 'cConsumo')
                            id_consumo = elred.entrega_id();
                            id_global_bus = this.VarOpt(indice_varopt).entrega_bus().entrega_id_global();
                            for oper = 1:length(this.vPuntosOperacion)
                                indice_nombre = indice_global_desde + oper -1;
                                texto = strcat('ENS_C', num2str(id_consumo), ...
                                               '_B', num2str(id_global_bus), ...
                                               '_O', num2str(oper));
                                this.NombreVariables{indice_nombre} = texto;
                            end
                        elseif isa(elred, 'cTransformador2D') || isa(elred, 'cLinea')
                            id_par = elred.entrega_indice_paralelo();
                            id_global_bus1 = this.VarOpt(indice_varopt).entrega_bus1().entrega_id_global();
                            id_global_bus2 = this.VarOpt(indice_varopt).entrega_bus2().entrega_id_global();
                            if isa(elred, 'cLinea')
                                tipo_cond = elred.entrega_tipo_conductor();
                            else
                                tipo_cond = elred.entrega_tipo_trafo();
                            end
                            if isa(elred, 'cLinea')
                                for oper = 1:length(this.vPuntosOperacion)
                                    indice_nombre = indice_global_desde + oper -1;
                                    texto = strcat('P_L', num2str(id_par), ...
                                                   '_C', num2str(tipo_cond), ...
                                                   '_B', num2str(id_global_bus1), ...
                                                   '_', num2str(id_global_bus2), ...
                                                   '_O', num2str(oper));
                                    this.NombreVariables{indice_nombre} = texto;
                                end
                            elseif isa(elred, 'cTransformador2D')
                                for oper = 1:length(this.vPuntosOperacion)
                                    indice_nombre = indice_global_desde + oper -1;
                                    texto = strcat('P_T', num2str(id_par), ...
                                                   '_Tipo', num2str(tipo_cond), ... 
                                                   '_B', num2str(id_global_bus1), ...
                                                   '_', num2str(id_global_bus2), ...
                                                   '_O', num2str(oper));
                                    this.NombreVariables{indice_nombre} = texto;
                                end
                            end
                        elseif isa(elred, 'cGenerador')
                            % se trata de un generador ERNC
                            id_bus = this.VarOpt(indice_varopt).entrega_bus().entrega_id_global();
                            for oper = 1:length(this.vPuntosOperacion)
                                indice_nombre = indice_global_desde + oper -1;
                                texto = strcat('PC_G', num2str(this.VarOpt(indice_varopt).entrega_elemento_red().entrega_id()), ...
                                               '_B', num2str(id_bus), '_O', num2str(oper));
                                this.NombreVariables{indice_nombre} = texto;
                            end
                        else
                        	error = MException('cOPF:ingresa_nombres',...
                                               ['Inconsistencia en los datos. Tipo elemento de red ' ...
                                               class(this.VarOpt(indice_varopt).entrega_elemento_red())...
                                               ' no está implementado en variable auxiliar y tipo variable P']);
                            throw(error)
                        end
                    elseif strcmp(unidades_varopt, 'Error_pos') || strcmp(unidades_varopt, 'Error_neg')
                        % puede ser una línea, un trafo 
                        id_par = this.VarOpt(indice_varopt).entrega_elemento_red().entrega_indice_paralelo();
                        if isa(this.VarOpt(indice_varopt).entrega_elemento_red(), 'cLinea')
                            id_global_bus1 = this.VarOpt(indice_varopt).entrega_bus1().entrega_elemento_red().entrega_id();
                            id_global_bus2 = this.VarOpt(indice_varopt).entrega_bus2().entrega_elemento_red().entrega_id();
                            tipo_cond = this.VarOpt(indice_varopt).entrega_elemento_red().entrega_tipo_conductor();
                            for oper = 1:length(this.vPuntosOperacion)
                                indice_nombre = indice_global_desde + oper -1;
                                texto = strcat(unidades_varopt, '_P_L', num2str(id_par), ...
                                               '_C', num2str(tipo_cond), ...
                                               '_B', num2str(id_global_bus1), ...
                                               '_', num2str(id_global_bus2), ...
                                               '_O', num2str(oper));
                                this.NombreVariables{indice_nombre} = texto;
                            end
                        elseif isa(this.VarOpt(indice_varopt).entrega_elemento_red(), 'cTransformador2D')
                            id_global_bus1 = this.VarOpt(indice_varopt).entrega_bus1().entrega_elemento_red().entrega_id();
                            id_global_bus2 = this.VarOpt(indice_varopt).entrega_bus2().entrega_elemento_red().entrega_id();
                            for oper = 1:length(this.vPuntosOperacion)
                                indice_nombre = indice_global_desde + oper -1;
                                texto = strcat(unidades_varopt, '_P_Tr', num2str(id_par), ...
                                               '_B', num2str(id_global_bus1), ...
                                               '_', num2str(id_global_bus2), ...
                                               '_O', num2str(oper));
                                this.NombreVariables{indice_nombre} = texto;
                            end
                        else
                            error = MException('cOPF:ingresa_nombres',...
                                               ['Inconsistencia en los datos. Tipo elemento de red ' ...
                                               class(this.VarOpt(indice_varopt).entrega_elemento_red())...
                                               ' no está implementado en variable auxiliar y tipo variable Q']);
                            throw(error)
                        end
                    else
                        error = MException('cOPF:ingresa_nombres',...
                                           ['Inconsistencia en los datos. Tipo de variable auxiliar con tipo de estado '...
                                             unidades_varopt ' no implementada']);
                        throw(error)
                    end                        
                otherwise
                        error = MException('cOPF:ingresa_nombres',...
                                           ['Inconsistencia en los datos. Tipo de variable '...
                                             tipo_varopt ' no implementada']);
                        throw(error)
            end
        end
        
        function copia_parametros_optimizacion(this, parametros)
            this.pParOpt.FuncionObjetivo = parametros.FuncionObjetivo;
            this.pParOpt.TipoFlujoPotencia = parametros.TipoFlujoPotencia;
            this.pParOpt.TipoRestriccionesSeguridad = parametros.TipoRestriccionesSeguridad;
            this.pParOpt.ConsideraDesprendimientoCarga = parametros.considera_desprendimiento_carga();
            this.pParOpt.PenalizacionRecorteRES = parametros.PenalizacionRecorteRES;
            this.pParOpt.Solver = parametros.Solver;
            
            this.iNivelDebug = parametros.NivelDebugOPF;
        end
        
        function ingresa_nombres_problema(this)
            this.NombreVariables = cell(length(this.VarOpt)*length(this.vPuntosOperacion),1);
            for i = 1:length(this.VarOpt)
                switch this.TipoVarOpt{i}
                    case 'VariableControl'
                        indice = this.VarOpt(i).entrega_varopt_operacion('P', 1);
                    case 'VariableEstado'
                        % ángulo de las subestaciones 
                        indice = this.VarOpt(i).entrega_varopt_operacion('Theta', 1);
                    case 'VariableAuxiliar'
                        switch this.UnidadesVarOpt{i}
                            case 'P'
                                % potencia activa de líneas y
                                % transformadores o energia no
                                % suministrada
                                indice = this.VarOpt(i).entrega_varopt_operacion('P', 1);
                        end
                end
                this.ingresa_nombres(i,indice, this.TipoVarOpt{i}, this.UnidadesVarOpt{i});
            end
            
            this.NombreEq = cell(this.iIndiceEq,1);
            pBuses = this.pSM.entrega_buses();
            eserie = this.pSM.entrega_elementos_serie();
            for oper = 1:length(this.vPuntosOperacion)
                for i = 1:length(pBuses)
                    id_restriccion_be = pBuses(i).entrega_indice_restriccion_balance_energia(1) + oper - 1;
                    this.NombreEq{id_restriccion_be} = strcat('req_', num2str(id_restriccion_be), '_be_', 'B', num2str(pBuses(i).entrega_id_global()), '_O', num2str(oper));
                end
            
                for i = 1:length(eserie)
                    id_restriccion = eserie(i).entrega_indice_restriccion_flujos_angulos(1) + oper - 1;
                    id_par = eserie(i).entrega_elemento_red().entrega_indice_paralelo();
                    bus1 = eserie(i).entrega_bus1();
                    bus2 = eserie(i).entrega_bus2();
                    if isa(eserie(i).entrega_elemento_red(), 'cLinea')
                        texto = 'L';
                    else
                        texto = 'Tr';
                    end
                	this.NombreEq{id_restriccion} = strcat('req_', num2str(id_restriccion), '_flujos_angulos', texto, num2str(id_par), ...
                        '_B', num2str(bus1.entrega_id_global()), '_', num2str(bus2.entrega_id_global()), '_O', num2str(oper));
                end
            end     
        end
        
        function elimina_nombres_problema(this)
            this.NombreVariables = [];
            this.NombreIneq = [];
            this.NombreEq = [];
        end
        
        function muestra_detalle_iteraciones(this,val)
            this.MuestraDetalleIteraciones = val;
        end
        
        function inserta_solver(this,val)
            this.pParOpt.Solver = val;
        end
 	end
end