classdef cDCOPF < cOPF
    properties
		pSEP = cSistemaElectricoPotencia.empty
        %pAdmOper = cAdministradorEscenariosOperacion.empty
		pResEvaluacion = cResultadoEvaluacionSEP.empty
        pParOpt = cParOptimizacionOPF.empty
        pAdmSc = cAdministradorEscenarios.empty
        Sbase = 0;
        
        VariablesInicializadas = false
        
        % resultados problema de optimizacion
        ResOptimizacion
        ExitFlag
        DescripcionFlag
        Fval
        Output
        Lambda
        
        % vectores con punteros a todos los elementos de red
        VarOpt= cElementoRed.empty
        
        % Elementos del sep. Indices a VarOpt, Indices de operación,
        % Indices a balances de energía, etc.
        Subestaciones = struct()
        Generadores = struct()
        Lineas = struct()
        Consumos = struct()
        Trafos = struct()
        Baterias = struct()
        Embalses = struct()
        
        
        %UnidadesVarOpt = cell.empty
        
        iCantPuntosOperacion = 0
        bHayDependenciaTemporal = false
        vIndicesPOConsecutivos = [] % cuando se consideran baterías y/o sistemas de almacenamiento. Largo indica cant. PO consecutivos. Ancho: indice po desde, indice po hasta
        
        
        % Parámetro de ACO. Indica la etapa correspondiente. TODO: Hay que eliminar esta variables. 
        % Por ahora se necesita para cargar los límites de la etapa
        % correspondiente. Estas se tienen que manejar directamente en el SEP
        iEtapa = 0
        iEscenario = 1
        
		Fobj  = [] %funcion objetivo
        Aeq = []  % matriz con restricciones de igualdad
        beq = []  % vector objetivo restricciones de igualdad
        Aineq = [] % matriz con restricciones de desigualdad
        bineq = []  % vector de desigualdades
        lb = [] %valores mínimos de variables de decisión
        ub = [] %valores máximos de variables de decisión

        InsertaResultadosEnSEP = true;
        
        % Sólo en modo debug
        NombreVariables = []
        NombreIneq = []
        NombreEq = []
        
        MuestraDetalleIteraciones = false
        
        iIndiceIneq = 0
        iIndiceEq = 0
        iNivelDebug = 2
        caso_estudio = 'caso_base'
        nombre_archivo = './output/dc_opf.dat'
        nombre_archivo_problema_opt = './output/dc_opf_problem_formulation.dat'
        nombre_archivo_detalle_variables = './output/variables_dc_opf.dat'
    end
    
    methods
	
		function this = cDCOPF(sep, varargin)                
			this.pSEP = sep;
            this.pParOpt = cParOptimizacionOPF();
            this.pResEvaluacion = cResultadoEvaluacionSEP(sep);
            this.pResEvaluacion.inserta_tipo_flujo_potencia('DC');
            this.pResEvaluacion.inserta_tipo_computo('OPF');
            this.pResEvaluacion.inserta_tipo_problema(this.pParOpt.entrega_tipo_problema());
            this.Sbase = cParametrosSistemaElectricoPotencia.getInstance.entrega_sbase();
            if nargin > 2
                %OPF para planificación
                this.pAdmSc = varargin{1};
                this.iCantPuntosOperacion = this.pAdmSc.entrega_cantidad_puntos_operacion();
                this.bConsideraDependenciaTemporal = this.pAdmSc.considera_dependencia_temporal();
                if this.bConsideraDependenciaTemporal
                    this.vIndicesPOConsecutivos = this.pAdmSc.entrega_indices_po_consecutivos();
                end
                % reemplaza parámetros del OPF por los indicados en
                % programa optimización correspondiente
                this.copia_parametros_optimizacion(varargin{2})
            end
        end
        
        function inserta_escenario(this, val)
            this.iEscenario = val;
        end
        
        function inserta_caso_estudio(this, caso_estudio)
            this.caso_estudio = caso_estudio;
        end
        
        function inserta_etapa(this, nro_etapa)
            % etapa se utiliza para ACO
            this.iEtapa = nro_etapa;
        end
        
        function etapa = entrega_etapa(this)
            etapa = this.iEtapa;
        end
                
        function inserta_sbase(this, val)
            this.Sbase = val;
        end        
                
        function inserta_nivel_debug(this, nivel)
            this.iNivelDebug = nivel;
        end
        
        function nivel = entrega_nivel_debug(this)
            nivel = this.iNivelDebug;
        end
        
        function inserta_resultados_en_sep(this, val)
            this.InsertaResultadosEnSEP = val;
        end
        
		function calcula_despacho_economico(this)
            if this.VariablesInicializadas == false
                this.iIndiceIneq = 0;
                this.iIndiceEq = 0;
                this.inicializa_variables();
                this.inicializa_contenedores();
			
                this.escribe_funcion_objetivo();
                this.escribe_restricciones();
                this.VariablesInicializadas = true;
            end
            if this.iNivelDebug > 1
                this.imprime_problema_optimizacion();
            end
            
			this.optimiza();
            if this.pResEvaluacion.ContenedoresInicializados
                this.pResEvaluacion.borra_evaluacion_actual();
            else
                this.pResEvaluacion.inicializa_contenedores(this.iCantPuntosOperacion);
            end
            
            if this.ExitFlag == 1
                % problema tiene solucion óptima
                this.pResEvaluacion.ExisteResultado = true;
                this.escribe_resultados();
                if this.iNivelDebug > 0
                    this.imprime_resultados_protocolo();
                end
            else
                this.pResEvaluacion.ExisteResultado = false;
                if this.iNivelDebug > 0
                    prot = cProtocolo.getInstance;
                    prot.imprime_texto('Problema de optimizacion invalido');
                    prot.imprime_texto(['Estado flag: ' num2str(this.ExitFlag)]);
                end
                % problema no tiene solucion
                % no se escriben resultados porque no tiene sentido
            end
        end
        
        function formula_problema_despacho_economico(this)
            this.iIndiceIneq = 0;
            this.iIndiceEq = 0;
            this.inicializa_variables();
            this.inicializa_contenedores();
			
            this.escribe_funcion_objetivo();
            this.escribe_restricciones();
            this.VariablesInicializadas = true;
        end
        
        function inicializa_variables(this)
            % Primero crea las variables de optimización y luego las
            % inicializa
            
            % variables de control (cuando flag opf esté activada): 
            % 1. potencia activa (despacho) de los generadores. También se
            % consideran los generadores RES en caso de que flag opf esté
            % activada
            % 
            % Variables de estado:
            % 2. Ángulos de los buses (la Slack se fija en cero pero se incluye como variable)
            %
            % Variables auxiliares (ayudan a la formulación del problema)
            % 2. Flujos por las líneas y transformadores.
            % 3. Consumos (para energía no suministrada)
            
            % variables de control.
            this.inserta_varopt(this.pSEP.entrega_generadores_despachables(), 'VariableControl', 'P');
            this.inserta_varopt(this.pSEP.entrega_baterias(), 'VariableControl', 'P');
            
            % variables de estado
            this.inserta_varopt(this.pSEP.entrega_subestaciones(), 'VariableEstado', 'Theta');
            
            % variables auxiliares.
            this.inserta_varopt(this.pSEP.entrega_lineas(), 'VariableAuxiliar', 'P');            
            this.inserta_varopt(this.pSEP.entrega_transformadores2d(), 'VariableAuxiliar', 'P')
            this.inserta_varopt(this.pSEP.entrega_baterias(), 'VariableAuxiliar', 'E');
            
            if this.pParOpt.considera_desprendimiento_carga()
                this.inserta_varopt(this.pSEP.entrega_consumos(), 'VariableAuxiliar', 'P');
            end

            if this.pParOpt.ConsideraRecorteRES
                this.inserta_varopt(this.pSEP.entrega_generadores_res(), 'VariableAuxiliar', 'P');
            end
            
            % Inicializa las variables
            if this.iNivelDebug > 1
                this.NombreVariables = cell(length(this.VarOpt)*this.iCantPuntosOperacion,1);
            end

            dec_redondeo = this.pParOpt.DecimalesRedondeo;
            
            cant_po = this.iCantPuntosOperacion;
            for i = 1:length(this.VarOpt)
                indice_desde = cant_po*(i-1) + 1;
                indice_hasta = cant_po*i;
                switch this.TipoVarOpt{i}
                    case 'VariableControl'
                        % Potencia de inyección de generador
                        % despachable y baterías
                        %elred.inserta_flag_opf(true);
                        if isa(this.VarOpt(i),'cGenerador')
                            if ~isempty(this.pAdmSc)
                                % factor de expansión para TNEP
                                if this.VarOpt(i).entrega_evolucion_capacidad_a_futuro(this.iEscenario)
                                    id_adm_sc = this.VarOpt(i).entrega_indice_adm_escenario_capacidad(this.iEscenario);
                                    pmax = this.pAdmSc.entrega_capacidad_generador(id_adm_sc, this.iEtapa)/this.Sbase;
                                else
                                    pmax = this.VarOpt(i).entrega_pmax()/this.Sbase;
                                end
                            else
                                pmax = this.VarOpt(i).entrega_pmax()/this.Sbase;
                            end
                            pmin = this.VarOpt(i).entrega_pmin()/this.Sbase;

                            if strcmp(this.pParOpt.entrega_tipo_problema(), 'Redespacho')
                                % problema de redespacho. se
                                % consideran los delta de los
                                % límites
                                p0 = this.VarOpt(i).entrega_p0_pu();
                                pmax = pmax - p0;
                                pmin = p0 - pmin;
                            end
                        elseif isa(this.VarOpt(i),'cBateria')
                            pmax = this.VarOpt(i).entrega_pmax_carga()/this.Sbase;
                            pmin = -1*this.VarOpt(i).entrega_pmax_descarga()/this.Sbase;
                        else
                            error = MException('cOPF:inicializa_variables',...
                                ['Inconsistencia en los datos en variable de control. Elemento de red ' class(this.VarOpt(i)) ' no corresponde. Tiene que ser o generador o batería']);
                            throw(error)
                        end

                        this.VarOpt(i).inserta_varopt_operacion('P', 1, 1, indice_desde);
                        this.VarOpt(i).inserta_varopt_operacion('P', 1, 2, indice_hasta);
                        this.lb(indice_desde:indice_hasta) = round(pmin,dec_redondeo);
                        this.ub(indice_desde:indice_hasta) = round(pmax,dec_redondeo);

                        if this.iNivelDebug > 0                      
                            this.ingresa_nombres(i, indice_desde, this.TipoVarOpt{i}, this.UnidadesVarOpt{i});
                        end
                    case 'VariableEstado'
                        % ángulo de las subestaciones 
                        this.VarOpt(i).inserta_varopt_operacion('Theta', 1, 1, indice_desde);
                        this.VarOpt(i).inserta_varopt_operacion('Theta', 1, 2, indice_hasta);
                        if this.VarOpt(i).es_slack()
                            this.lb(indice_desde:indice_hasta) = 0;
                            this.ub(indice_desde:indice_hasta) = 0;
                        else
                            this.lb(indice_desde:indice_hasta) = round(-pi,dec_redondeo);
                            this.ub(indice_desde:indice_hasta) = round(pi,dec_redondeo);
                        end
                        if this.iNivelDebug > 0
                            this.ingresa_nombres(i, indice_desde, this.TipoVarOpt{i}, this.UnidadesVarOpt{i});
                        end
                    case 'VariableAuxiliar'
                        switch this.UnidadesVarOpt{i}
                            case 'P'
                                % potencia activa de líneas y
                                % transformadores o energia no
                                % suministrada
                                this.VarOpt(i).inserta_varopt_operacion('P', 1, 1, indice_desde);
                                this.VarOpt(i).inserta_varopt_operacion('P', 1, 2, indice_hasta);
                                if isa(this.VarOpt(i), 'cLinea') || isa(this.VarOpt(i), 'cTransformador2D')
                                    sr = this.VarOpt(i).entrega_sr()/this.Sbase;
                                    this.lb(indice_desde:indice_hasta) = -sr;
                                    this.ub(indice_desde:indice_hasta) = sr;
                                elseif isa(this.VarOpt(i), 'cConsumo')
                                    if ~isempty(this.pAdmSc)
                                        indice_perfil = this.VarOpt(i).entrega_indice_adm_escenario_perfil();
                                        perfil = this.pAdmSc.entrega_perfil_consumo(indice_perfil);
                                        indice_capacidad = this.VarOpt(i).entrega_indice_adm_escenario_capacidad(this.iEscenario);
                                        capacidad = this.pAdmSc.entrega_capacidad_consumo(indice_capacidad, this.iEtapa);
                                        consumo_max = capacidad*perfil/this.Sbase;                            
                                    else
                                        % sólo un punto de operación
                                        consumo_max = -this.VarOpt(i).entrega_p_const_nom_pu(); %valor positivo
                                    end
                                    this.lb(indice_desde:indice_hasta) = 0;
                                    this.ub(indice_desde:indice_hasta) = round(consumo_max',dec_redondeo);
                                elseif isa(this.VarOpt(i), 'cGenerador')
                                    if ~isempty(this.pAdmSc)
                                        if this.VarOpt(i).entrega_evolucion_capacidad_a_futuro(this.iEscenario)
                                            id_adm_sc = this.VarOpt(i).entrega_indice_adm_escenario_capacidad(this.iEscenario);
                                            capacidad = this.pAdmSc.entrega_capacidad_generador(id_adm_sc, this.iEtapa);
                                            id_adm_sc = this.VarOpt(i).entrega_indice_adm_escenario_perfil_ernc();
                                            pmax = capacidad*this.pAdmSc.entrega_perfil_ernc(id_adm_sc)/this.Sbase;                                        
                                        else
                                            pmax = this.VarOpt(i).entrega_p_const_nom_opf(); % ya está en pu
                                        end
                                    else
                                        % sólo un punto de operación
                                        pmax = this.VarOpt(i).entrega_p_const_nom_opf();                                        
                                    end
                                    this.lb(indice_desde:indice_hasta) = 0;
                                    this.ub(indice_desde:indice_hasta) = round(pmax',dec_redondeo);
                                else
                                    error = MException('cOPF:inicializa_variables',...
                                        ['Inconsistencia en los datos en variable auxiliar P. Elemento de red ' class(this.VarOpt(i)) ' no corresponde']);
                                    throw(error)
                                end
                                if this.iNivelDebug > 0
                                    this.ingresa_nombres(i, indice_desde, this.TipoVarOpt{i}, this.UnidadesVarOpt{i});
                                end
                            otherwise
                                error = MException('cOPF:inicializa_variables',...
                                    ['Inconsistencia en los datos en variable auxiliar. Tipo ' this.UnidadesVarOpt{i} ' no corresponde']);
                                throw(error)
                        end
                    otherwise
                        error = MException('cOPF:inicializa_variables',...
                            ['Inconsistencia en los datos. Tipo de variable de control ' this.TipoVarOpt{i} ' no corresponde']);
                        throw(error)
                end
            end            
        end

        function agrega_variable(this, variable)
            % variable es elemento del SEP
            % Esta función es peligrosa. Fue definida sólo para
            % TNEP para mejorar performance!

            dec_redondeo = this.pParOpt.DecimalesRedondeo;
            
            indice = length(this.Fobj);
            % agrega nueva variable a función objetivo. Como sólo se
            % trata de nuevas líneas y transformadores, estos no afectan a
            % la función objetivo
            this.Fobj = [this.Fobj; zeros(this.iCantPuntosOperacion, 1)];

            % actualiza dimensión de restricciones de igualdad
            this.Aeq = [this.Aeq zeros(this.iIndiceEq, this.iCantPuntosOperacion)];
            
            indice_desde = indice + 1;
            indice_hasta = indice + this.iCantPuntosOperacion;
            
            if isa(variable, 'cSubestacion')
                this.agrega_varopt(variable, 'VariableEstado', 'Theta');                
                variable.inserta_varopt_operacion('Theta', 1, 1, indice_desde);
                variable.inserta_varopt_operacion('Theta', 1, 2, indice_hasta);
                this.lb(indice_desde:indice_hasta) = round(-pi,dec_redondeo);
                this.ub(indice_desde:indice_hasta) = round(pi,dec_redondeo);
                if this.iNivelDebug > 0
                    this.ingresa_nombres(length(this.VarOpt), indice_desde, 'VariableEstado', 'Theta');
                end

                % agrega nueva restricción para balance de energía
                this.agrega_balance_energia(variable);
            elseif isa(variable, 'cLinea') || isa(variable, 'cTransformador2D')
                this.agrega_varopt(variable, 'VariableAuxiliar', 'P');
                variable.inserta_varopt_operacion('P', 1, 1, indice_desde);
                variable.inserta_varopt_operacion('P', 1, 2, indice_hasta);
                sr = variable.entrega_sr()/this.Sbase;
                this.lb(indice_desde:indice_hasta) = -sr;
                this.ub(indice_desde:indice_hasta) = sr;
                if this.iNivelDebug > 0
                    this.ingresa_nombres(length(this.VarOpt), indice_desde, 'VariableAuxiliar', 'P');
                end
                this.actualiza_balance_energia(variable);
                this.agrega_relaciones_flujos_angulos(variable)
            elseif isa(variable, 'cBateria')
                this.agrega_varopt(variable, 'VariableControl', 'P');
                variable.inserta_varopt_operacion('P', 1, 1, indice_desde);
                variable.inserta_varopt_operacion('P', 1, 2, indice_hasta);
                pmax = variable.entrega_pmax_carga()/this.Sbase;
                pmin = -1*variable.entrega_pmax_descarga()/this.Sbase;
                this.lb(indice_desde:indice_hasta) = pmin;
                this.ub(indice_desde:indice_hasta) = pmax;
            else
                error = MException('cOPF:agrega_variable','Tipo de variable aún no implementada. Sólo buses y elementos serie. Ningún elemento paralelo');
                throw(error)
            end
            
            if ~isempty(this.pResEvaluacion)
                if isa(variable, 'cSubestacion')
                    this.pResEvaluacion.agrega_subestacion();
                elseif isa(variable, 'cLinea') 
                    this.pResEvaluacion.agrega_linea(variable);
                elseif isa(variable, 'cTransformador2D')
                    this.pResEvaluacion.agrega_transformador(variable);
                end
            end
        end

        function elimina_variable(this, variable)
            % variable es elemento del SEP
            % Esta función es peligrosa. Fue definida sólo para
            % TNEP para mejorar performance!
            cant_po = this.iCantPuntosOperacion;
            % primero identifica id de restricción
            if isa(variable, 'cSubestacion')
                indice_varopt_operacion_desde = variable.entrega_varopt_operacion('Theta', 1,1);
                indice_varopt_operacion_hasta = variable.entrega_varopt_operacion('Theta', 1,2);
                % se elimina balance de energía. Se verifica eso sí que no
                % haya ningún elemento conectado aún
                id_restriccion_desde = variable.entrega_indice_restriccion_balance_energia(1);
                id_restriccion_hasta = variable.entrega_indice_restriccion_balance_energia(2);
                
                if ~isempty(nonzeros(this.Aeq(id_restriccion_desde:id_restriccion_hasta,:)))
                    error = MException('cOPF:elimina_variable','Error de programación. No se puede eliminar bus, porque aún existen variables en balance de energía!');
                    throw(error)
                end
            elseif isa(variable, 'cLinea') || isa(variable, 'cTransformador2D')
                indice_varopt_operacion_desde = variable.entrega_varopt_operacion('P', 1,1);
                indice_varopt_operacion_hasta = variable.entrega_varopt_operacion('P', 1,2);
                %elimina variable de balance de energía

                id_restriccion_desde = variable.entrega_indice_restriccion_flujos_angulos(1);
                id_restriccion_hasta = variable.entrega_indice_restriccion_flujos_angulos(2);
                
            elseif isa(variable, 'cBateria')
                indice_varopt_operacion_desde = variable.entrega_varopt_operacion('P', 1,1);
                indice_varopt_operacion_hasta = variable.entrega_varopt_operacion('P', 1,2);
                id_restriccion_desde = variable.entrega_indice_restriccion_balance_energia(1);
                id_restriccion_hasta = variable.entrega_indice_restriccion_balance_energia(2);
            else
                error = MException('cOPF:elimina_variable','Error de programación. Sólo se pueden eliminar buses o elementos serie. No elementos paralelos');
                throw(error)
            end

            % elimina restriccion
            this.Aeq(id_restriccion_desde:id_restriccion_hasta,:) = [];
            this.beq(id_restriccion_desde:id_restriccion_hasta) = [];
            this.iIndiceEq = this.iIndiceEq - cant_po;

            if ~isempty(this.NombreEq)
                this.NombreEq(id_restriccion_desde:id_restriccion_hasta) = [];
            end

            %actualiza índices de restricciones de igualdad para el resto
            %de los elementos (buses y elementos serie). 
            %RAMRAM TODO: Eventualmente un método más eficiente?
            for i = 1:length(this.VarOpt)
                if isa(this.VarOpt(i), 'cSubestacion')
                    id_be_desde = this.VarOpt(i).entrega_indice_restriccion_balance_energia(1);
                    id_be_hasta = this.VarOpt(i).entrega_indice_restriccion_balance_energia(2);

                    if id_be_desde > id_restriccion_desde
                        this.VarOpt(i).agrega_indice_restriccion_balance_energia(1, id_be_desde - cant_po);
                        this.VarOpt(i).agrega_indice_restriccion_balance_energia(2, id_be_hasta - cant_po);
                    end
                elseif isa(this.VarOpt(i), 'cLinea') || isa(this.VarOpt(i), 'cTransformador2D')
                    id_fa_desde = this.VarOpt(i).entrega_indice_restriccion_flujos_angulos(1);
                    id_fa_hasta = this.VarOpt(i).entrega_indice_restriccion_flujos_angulos(2);
                    if id_fa_desde > id_restriccion_desde
                        this.VarOpt(i).agrega_indice_restriccion_flujos_angulos(1,id_fa_desde - cant_po);
                        this.VarOpt(i).agrega_indice_restriccion_flujos_angulos(2,id_fa_hasta - cant_po);
                    end
                elseif isa(variable, 'cBateria')
linlinlin
% FALTA HACER. EVENTUALMENTE LOS INDICES DE RESTRICCIONES SE PUEDEN GUARDAR
% EN FORMA LOCAL AQUÍ. ESTO AYUDARÍA A MEJORAR PERFORMANCE
                end
            end

            % elimina variable de contenedores
            this.Fobj(indice_varopt_operacion_desde:indice_varopt_operacion_hasta) = [];
            this.lb(indice_varopt_operacion_desde:indice_varopt_operacion_hasta) = [];
            this.ub(indice_varopt_operacion_desde:indice_varopt_operacion_hasta) = [];
            if ~isempty(this.NombreVariables)
                this.NombreVariables(indice_varopt_operacion_desde:indice_varopt_operacion_hasta) = [];
            end
            this.Aeq(:,indice_varopt_operacion_desde:indice_varopt_operacion_hasta) = [];

            % actualiza índice del resto de las variables
            % TODO RAMRAM: Puede no ser eficiente... alternativa?
            for i = 1:length(this.VarOpt)
                if isa(this.VarOpt(i), 'cSubestacion')
                    id_varopt_op_desde = this.VarOpt(i).entrega_varopt_operacion('Theta', 1,1);
                    id_varopt_op_hasta = this.VarOpt(i).entrega_varopt_operacion('Theta', 1,2);
                    if id_varopt_op_desde > indice_varopt_operacion_desde
                        this.VarOpt(i).inserta_varopt_operacion('Theta', 1, 1, id_varopt_op_desde - cant_po);
                        this.VarOpt(i).inserta_varopt_operacion('Theta', 1, 2, id_varopt_op_hasta - cant_po);
                    end
                else
linlinlin
% FALTA VER QUÉ SE HACE CON LAS BATERÍAS
                    id_varopt_op_desde = this.VarOpt(i).entrega_varopt_operacion('P', 1,1);
                    id_varopt_op_hasta = this.VarOpt(i).entrega_varopt_operacion('P', 1,2);
                    if id_varopt_op_desde > indice_varopt_operacion_desde
                        this.VarOpt(i).inserta_varopt_operacion('P', 1, 1,id_varopt_op_desde - cant_po);
                        this.VarOpt(i).inserta_varopt_operacion('P', 1, 2,id_varopt_op_hasta - cant_po);
                    end
                end
            end
            
            % se borra varopt
            id_varopt = variable.entrega_pos_varopt();
            this.VarOpt(id_varopt) = [];
            this.TipoVarOpt(id_varopt) = [];
            this.UnidadesVarOpt(id_varopt) = [];

            for i = 1:length(this.VarOpt)
                id_otro = this.VarOpt(i).entrega_pos_varopt();
                if id_otro > id_varopt
                    this.VarOpt(i).inserta_pos_varopt(id_otro-1);
                end
            end

            % finalmente se actualizan los resultados de la evaluación
            if ~isempty(this.pResEvaluacion)
                if isa(variable, 'cSubestacion')
                    this.pResEvaluacion.elimina_subestacion();
                elseif isa(variable, 'cLinea') 
                    this.pResEvaluacion.elimina_linea(variable);
                elseif isa(variable, 'cTransformador2D')
                    this.pResEvaluacion.elimina_transformador(variable);
                elseif isa(variable, 'cBateria')
                    this.pResEvaluacion.elimina_bateria(variable);
                end
            end
        end
        
        function inicializa_contenedores(this)
            % se inicializan las dimensiones de las matrices. 

            n_var = length(this.VarOpt)*this.iCantPuntosOperacion;
            this.Fobj = zeros(n_var, 1);
            
            % Restricciones de igualdad contiene: 
            % 1. Balance de energía por nodo y punto de operación
            %    Cantidad: #buses *#po
            % 2. Restricciones flujos-ángulos
            %    Cantidad: #elementos serie *#po

            n_buses = this.pSEP.entrega_cantidad_subestaciones();
            n_serie = this.pSEP.entrega_cantidad_elementos_serie();
            cantidad_eq = (n_buses+n_serie)*this.iCantPuntosOperacion;

            this.Aeq = sparse(cantidad_eq, n_var);
            this.beq = zeros(cantidad_eq, 1);
            %this.NombreEq = cell(cantidad_rest_igualdad,1);        
            if this.iNivelDebug > 0
                this.NombreEq = cell(cantidad_eq,1);
            end
            % por ahora no hay restricciones de desigualdad
            cantidad_ineq = 0;
            this.Aineq = [];
            this.bineq = [];
            
            if this.iNivelDebug > 1
                prot = cProtocolo.getInstance;
                prot.imprime_texto('Dimension de contenedores (antes de escribir las restricciones)');
                prot.imprime_texto(['Cantidad variables decision: ' num2str(n_var)]);
                prot.imprime_texto(['Cantidad rest. igualdad: ' num2str(cantidad_eq)]);
                prot.imprime_texto(['Cantidad rest. desigualdad: ' num2str(cantidad_ineq)]);
            end
        end
        
        function escribe_funcion_objetivo(this)
            dec_redondeo= this.pParOpt.DecimalesRedondeo;
            
            if strcmp(this.pParOpt.entrega_funcion_objetivo(), 'MinC')
                    % Costo de generación
                    % no es eficiente pero en este punto no se necesita
                    % rapidez (... o si? TODO: Evaluar!)
                    for i = 1:length(this.VarOpt)
                        if isa(this.VarOpt(i), 'cGenerador')
                            if strcmp(this.TipoVarOpt{i}, 'VariableControl')
                                costo_mwh = this.VarOpt(i).entrega_costo_mwh_pu();
                                indice_desde = this.VarOpt(i).entrega_varopt_operacion('P', 1,1);
                                indice_hasta = this.VarOpt(i).entrega_varopt_operacion('P', 1,2);
                                this.Fobj(indice_desde:indice_hasta) = round(costo_mwh,dec_redondeo);
                            elseif strcmp(this.TipoVarOpt{i}, 'VariableAuxiliar')
                                penalizacion = this.pParOpt.entrega_penalizacion_recorte_res(); % en $/MWh
                                indice_desde = this.VarOpt(i).entrega_varopt_operacion('P', 1,1);
                                indice_hasta = this.VarOpt(i).entrega_varopt_operacion('P', 1,2);
                                this.Fobj(indice_desde:indice_hasta) = round(penalizacion*this.Sbase,dec_redondeo);
                            end
                        elseif isa(this.VarOpt(i), 'cConsumo')
                            costo_desconexion = this.VarOpt(i).entrega_costo_desconexion_carga_pu();
                            if costo_desconexion == 0
                                error = MException('cOPF:escribe_funcion_objetivo','Costo de desconexión de carga igual a cero');
                                throw(error)
                            end
                            indice_desde = this.VarOpt(i).entrega_varopt_operacion(this.UnidadesVarOpt{i}, 1, 1);
                            indice_hasta = this.VarOpt(i).entrega_varopt_operacion(this.UnidadesVarOpt{i}, 1, 2);
                            this.Fobj(indice_desde:indice_hasta) = round(costo_desconexion,dec_redondeo);
                        end
                    end
            else
                error = MException('cOPF:escribe_funcion_objetivo','Función objetivo indicada no implementada');
                throw(error)
            end
        end
        
        function escribe_restricciones(this)
            this.escribe_balance_energia();
            this.escribe_relaciones_flujos_angulos();
            % no se necesita restringir el ángulo máximo entre los
            % buses, ya que flujo máximo por las líneas es más
            % restrictivo
            %this.escribe_restricciones_angulos_buses(oper);
        end

        function escribe_balance_energia(this)
            pBuses = this.pSEP.entrega_subestaciones();
            cant_po = this.iCantPuntosOperacion;
            dec_redondeo = this.pParOpt.DecimalesRedondeo;
            for i = 1:length(pBuses)
                indice_eq_desde = this.iIndiceEq +1;
                indice_eq_hasta = this.iIndiceEq +cant_po;                
                this.iIndiceEq = this.iIndiceEq +cant_po;
                pBuses(i).agrega_indice_restriccion_balance_energia(1, indice_eq_desde);
                pBuses(i).agrega_indice_restriccion_balance_energia(2, indice_eq_hasta);
                
                % Balance de potencia activa en bus
                %generadores
                pGeneradores = pBuses(i).entrega_generadores_despachables();
                for j = 1:length(pGeneradores)
                    indice_gen_desde = pGeneradores(j).entrega_varopt_operacion('P', 1, 1);
                    indice_gen_hasta = pGeneradores(j).entrega_varopt_operacion('P', 1, 2);
                    this.Aeq(indice_eq_desde:indice_eq_hasta,indice_gen_desde:indice_gen_hasta) = this.Aeq(indice_eq_desde:indice_eq_hasta,indice_gen_desde:indice_gen_hasta) + diag(ones(cant_po,1));
                    %for oper = 1:cant_po
                    %    this.Aeq(indice_eq_desde + oper - 1,indice_gen_desde + oper - 1) = 1;
                    %end
                end

                %ENS
                if this.pParOpt.considera_desprendimiento_carga()
                    pConsumos = pBuses(i).entrega_consumos();
                    for j = 1:length(pConsumos)
                        indice_consumo_desde = pConsumos(j).entrega_varopt_operacion('P', 1, 1);
                        indice_consumo_hasta = pConsumos(j).entrega_varopt_operacion('P', 1, 2);
                        this.Aeq(indice_eq_desde:indice_eq_hasta,indice_consumo_desde:indice_consumo_hasta) = this.Aeq(indice_eq_desde:indice_eq_hasta,indice_consumo_desde:indice_consumo_hasta) + diag(ones(cant_po,1));
                        %for oper = 1:cant_po
                        %    this.Aeq(indice_eq_desde + oper - 1,indice_consumo_desde + oper - 1) = 1;
                        %end
                    end
                end
                
                % Recorte RES.
                if this.pParOpt.ConsideraRecorteRES                    
                    pGeneradores_ernc = pBuses(i).entrega_generadores_res();
                    for j = 1:length(pGeneradores_ernc)
                        indice_generador_desde = pGeneradores_ernc(j).entrega_varopt_operacion('P', 1, 1);
                        indice_generador_hasta = pGeneradores_ernc(j).entrega_varopt_operacion('P', 1, 2);
                        this.Aeq(indice_eq_desde:indice_eq_hasta,indice_generador_desde:indice_generador_hasta) = this.Aeq(indice_eq_desde:indice_eq_hasta,indice_generador_desde:indice_generador_hasta) + diag(ones(cant_po,1))*-1;
                        %for oper = 1:cant_po
                        %    this.Aeq(indice_eq_desde + oper - 1,indice_generador_desde + oper - 1) = -1;
                        %end
                    end
                end
                
                %consumo residual
                consumo_residual_p = zeros(cant_po,1);
                elpar = pBuses(i).entrega_elementos_paralelos();
                for ii = 1:length(elpar)
                    valor_elemento = zeros(1,cant_po);
                    if isa(elpar(ii), 'cConsumo')
                        if ~isempty(this.pAdmSc)
                            indice_perfil = elpar(ii).entrega_indice_adm_escenario_perfil();
                            perfil = this.pAdmSc.entrega_perfil_consumo(indice_perfil);
                            indice_capacidad = elpar(ii).entrega_indice_adm_escenario_capacidad(this.iEscenario);
                            capacidad = this.pAdmSc.entrega_capacidad_consumo(indice_capacidad, this.iEtapa);
                            valor_elemento = -capacidad*perfil/this.Sbase;
                        else
                            % sólo un punto de operación
                            valor_elemento = elpar(ii).entrega_p_const_nom_pu(); %valor positivo
                        end
                    elseif isa(elpar(ii), 'cGenerador')
                        if elpar(ii).es_ernc()
                            if ~isempty(this.pAdmSc)
                                if elpar(ii).entrega_evolucion_capacidad_a_futuro(this.iEscenario)
                                    id_adm_sc = elpar(ii).entrega_indice_adm_escenario_capacidad(this.iEscenario);
                                    capacidad = this.pAdmSc.entrega_capacidad_generador(id_adm_sc, this.iEtapa);
                                    id_adm_sc = elpar(ii).entrega_indice_adm_escenario_perfil_ernc();
                                    valor_elemento = capacidad*this.pAdmSc.entrega_perfil_ernc(id_adm_sc)/this.Sbase;                                        
                                else
                                    valor_elemento = elpar(ii).entrega_p_const_nom_opf(); % ya está en pu
                                end
                            else
                                valor_elemento = elpar(ii).entrega_p_const_nom_opf(); % ya está en pu
                            end
                        end
                    end
                    consumo_residual_p = consumo_residual_p + valor_elemento';
                end
                this.beq(indice_eq_desde:indice_eq_hasta) = round(-consumo_residual_p,dec_redondeo);

                % elementos serie
                eserie = pBuses(i).entrega_elementos_serie();
                for j = 1:length(eserie)
                    indice_eserie_p_desde = eserie(j).entrega_varopt_operacion('P', 1, 1);
                    indice_eserie_p_hasta = eserie(j).entrega_varopt_operacion('P', 1, 2);
                    
                    bus1 = eserie(j).entrega_se1();
                    bus2 = eserie(j).entrega_se2();
                    if bus1 == pBuses(i)
                        % inicio linea corresponde a este bus, por lo tanto
                        % flujo sale
                        signo = -1;
                    elseif bus2 == pBuses(i)
                        signo = 1;
                    else
                        error = MException('cOPF:escribe_balance_energia','Inconsistencia en los datos, ya que elemento serie no pertenece a bus');
                        throw(error)
                    end
                    
                    this.Aeq(indice_eq_desde:indice_eq_hasta,indice_eserie_p_desde:indice_eserie_p_hasta) = this.Aeq(indice_eq_desde:indice_eq_hasta,indice_eserie_p_desde:indice_eserie_p_hasta) + diag(ones(cant_po,1))*signo;
                    %for oper = 1:cant_po
                    %    this.Aeq(indice_eq_desde + oper - 1,indice_eserie_p_desde + oper - 1) = signo;
                    %end
                    if this.iNivelDebug > 0
                        for oper = 1:cant_po                        
                            this.NombreEq{indice_eq_desde + oper - 1} = strcat('req_', num2str(indice_eq_desde + oper - 1), '_be_', 'B', num2str(pBuses(i).entrega_id()), '_O', num2str(oper));
                        end
                    end
                end
            end
        end

        function actualiza_etapa(this, etapa)
            this.iEtapa = etapa;
            cant_po = this.iCantPuntosOperacion;
            dec_redondeo = this.pParOpt.DecimalesRedondeo;
            %actualiza potencias de los generadores y consumos (ens) de acuerdo a
            %la etapa
            for i = 1:length(this.VarOpt)
                switch this.TipoVarOpt{i}
                    case 'VariableControl'
                        % Potencia de inyección del generador. Sólo si
                        % capacidad evoluciona a futuro. Si no, no es
                        % necesario hacer ningún cambio
                        if this.VarOpt(i).entrega_evolucion_capacidad_a_futuro(this.iEscenario)
                            id_adm_sc = this.VarOpt(i).entrega_indice_adm_escenario_capacidad(this.iEscenario);
                            pmax = this.pAdmSc.entrega_capacidad_generador(id_adm_sc, etapa)/this.Sbase;
                            
                            %OJO: Pmin no cambia. Se deja aquí por si a
                            %futuro es necesario agregar cambios en pmin
                            pmin = this.VarOpt(i).entrega_pmin()/this.Sbase;

                            if strcmp(this.pParOpt.entrega_tipo_problema(), 'Redespacho')
                                % problema de redespacho. se
                                % consideran los delta de los
                                % límites
                                if this.VarOpt(i).es_despachable()
                                    p0 = this.VarOpt(i).entrega_p0_pu();
                                    pmax = pmax - p0;
                                    pmin = p0 - pmin;
                                end
                            end
                            indice_varopt_operacion_desde = this.VarOpt(i).entrega_varopt_operacion('P', 1, 1);
                            indice_varopt_operacion_hasta = this.VarOpt(i).entrega_varopt_operacion('P', 1, 2);
                            this.lb(indice_varopt_operacion_desde:indice_varopt_operacion_hasta) = round(pmin,dec_redondeo);
                            this.ub(indice_varopt_operacion_desde:indice_varopt_operacion_hasta) = round(pmax,dec_redondeo);
                        end
                        %if this.iNivelDebug > 1
                        %    this.ingresa_nombres(indice, oper, this.TipoVarOpt{i}, this.UnidadesVarOpt{i});
                        %end
                    case 'VariableEstado'
                        % nada que hacer, ya que ángulo de las
                        % subestaciones ya fueron definidos
                    case 'VariableAuxiliar'
                        switch this.UnidadesVarOpt{i}
                            case 'P'
                                % potencia activa de líneas y
                                % transformadores o energia no
                                % suministrada o recorte res
                                if isa(this.VarOpt(i), 'cLinea') || isa(this.VarOpt(i), 'cTransformador2D')
                                    % nada que hacer, ya que límites ya
                                    % fueron definidos
                                elseif isa(this.VarOpt(i), 'cConsumo')
                                    %actualiza condumos
                                    indice_varopt_operacion_desde = this.VarOpt(i).entrega_varopt_operacion('P', 1, 1);
                                    indice_varopt_operacion_hasta = this.VarOpt(i).entrega_varopt_operacion('P', 1, 2);
                                    indice_perfil = this.VarOpt(i).entrega_indice_adm_escenario_perfil();
                                    perfil = this.pAdmSc.entrega_perfil_consumo(indice_perfil);
                                    indice_capacidad = this.VarOpt(i).entrega_indice_adm_escenario_capacidad(this.iEscenario);
                                    capacidad = this.pAdmSc.entrega_capacidad_consumo(indice_capacidad, etapa);
                                    consumo_max = capacidad*perfil/this.Sbase;
                                    %this.lb(indice) = 0;
                                    this.ub(indice_varopt_operacion_desde:indice_varopt_operacion_hasta) = round(consumo_max,dec_redondeo);
                                elseif isa(this.VarOpt(i), 'cGenerador')
                                    % generador ernc
                                    indice_varopt_operacion_desde = this.VarOpt(i).entrega_varopt_operacion('P',1, 1);
                                    indice_varopt_operacion_hasta = this.VarOpt(i).entrega_varopt_operacion('P',1, 2);

                                    if this.VarOpt(i).entrega_evolucion_capacidad_a_futuro(this.iEscenario)
                                        id_adm_sc = this.VarOpt(i).entrega_indice_adm_escenario_capacidad(this.iEscenario);
                                        capacidad = this.pAdmSc.entrega_capacidad_generador(id_adm_sc, etapa);
                                        id_adm_sc = this.VarOpt(i).entrega_indice_adm_escenario_perfil_ernc();
                                        pmax = capacidad*this.pAdmSc.entrega_perfil_ernc(id_adm_sc)/this.Sbase;
                                        this.ub(indice_varopt_operacion_desde:indice_varopt_operacion_hasta) = round(pmax',dec_redondeo);
                                    end
                                else
                                    error = MException('cOPF:actualiza_etapa',...
                                        ['Inconsistencia en los datos en variable auxiliar P. Elemento de red ' class(this.VarOpt(i)) ' no corresponde']);
                                    throw(error)
                                end
                            otherwise
                                error = MException('cOPF:actualiza_etapa',...
                                    ['Inconsistencia en los datos en variable auxiliar. Tipo ' this.UnidadesVarOpt{i} ' no corresponde']);
                                throw(error)
                        end
                    otherwise
                        error = MException('cOPF:actualiza_etapa',...
                            ['Inconsistencia en los datos. Tipo de variable de control ' this.TipoVarOpt{i} ' no corresponde']);
                        throw(error)
                end
            end

            %actualiza balance de energía
            pBuses = this.pSEP.entrega_subestaciones();
            for i = 1:length(pBuses)
                id_restriccion_be_desde = pBuses(i).entrega_indice_restriccion_balance_energia(1);
                id_restriccion_be_hasta = pBuses(i).entrega_indice_restriccion_balance_energia(2);

                %consumo residual
                consumo_residual_p = zeros(cant_po,1);
                elpar = pBuses(i).entrega_elementos_paralelos();
                for ii = 1:length(elpar)
                    valor_elemento = zeros(1,cant_po);
                    if isa(elpar(ii), 'cConsumo')
                        indice_perfil = elpar(ii).entrega_indice_adm_escenario_perfil();
                        perfil = this.pAdmSc.entrega_perfil_consumo(indice_perfil);
                        indice_capacidad = elpar(ii).entrega_indice_adm_escenario_capacidad(this.iEscenario);
                        capacidad = this.pAdmSc.entrega_capacidad_consumo(indice_capacidad, etapa);
                        valor_elemento = -capacidad*perfil/this.Sbase;                            
                    elseif isa(elpar(ii), 'cGenerador')
                        if elpar(ii).es_ernc()
                            if elpar(ii).entrega_evolucion_capacidad_a_futuro(this.iEscenario)
                                id_adm_sc = elpar(ii).entrega_indice_adm_escenario_capacidad(this.iEscenario);
                                capacidad = this.pAdmSc.entrega_capacidad_generador(id_adm_sc, etapa);
                                id_adm_sc = elpar(ii).entrega_indice_adm_escenario_perfil_ernc();
                                valor_elemento = capacidad*this.pAdmSc.entrega_perfil_ernc(id_adm_sc)/this.Sbase;                                        
                            else
                                valor_elemento = elpar(ii).entrega_p_const_nom_opf(); % ya está en pu
                            end
                        end
                    end
                    consumo_residual_p = consumo_residual_p + valor_elemento';
                end
                this.beq(id_restriccion_be_desde:id_restriccion_be_hasta) = round(-consumo_residual_p,dec_redondeo);
            end
        end
        
		function calcula_despacho_economico_sin_restricciones_red(this)
            if this.VariablesInicializadas == false
                this.iIndiceIneq = 0;
                this.iIndiceEq = 0;
                this.inicializa_variables();
                this.inicializa_contenedores();
			
                this.escribe_funcion_objetivo();
                this.escribe_restricciones();
                this.VariablesInicializadas = true;
            end
            
            % desactiva las restricciones de red
            this.desactiva_restricciones_red();
            
            if this.iNivelDebug > 1
                this.imprime_problema_optimizacion();
            end
            
			this.optimiza();
            this.pResEvaluacion.inicializa_contenedores(this.iCantPuntosOperacion);
            if this.ExitFlag == 1
                % problema tiene solucion óptima
                this.pResEvaluacion.ExisteResultado = true;
                this.escribe_resultados();
                if this.iNivelDebug > 0
                    this.imprime_resultados_protocolo();
                end
            else
                this.pResEvaluacion.ExisteResultado = false;
                if this.iNivelDebug > 0
                    prot = cProtocolo.getInstance;
                    prot.imprime_texto('Problema de optimizacion invalido');
                    prot.imprime_texto(['Estado flag: ' num2str(this.ExitFlag)]);
                end
                % problema no tiene solucion
                % no se escriben resultados porque no tiene sentido
                
            end            
            this.activa_restricciones_red();
        end
        
        function desactiva_restricciones_red(this)
            dec_redondeo = this.pParOpt.DecimalesRedondeo;
            for i = 1:length(this.VarOpt)
                switch this.TipoVarOpt{i}
                    case 'VariableControl'
                        % nada
                    case 'VariableEstado'
                        % ángulo de las subestaciones 
                        indice_desde = this.VarOpt(i).entrega_varopt_operacion('Theta',1,1);
                        indice_hasta = this.VarOpt(i).entrega_varopt_operacion('Theta',1,2);
                        if this.VarOpt(i).es_slack()
                            this.lb(indice_desde:indice_hasta) = 0;
                            this.ub(indice_desde:indice_hasta) = 0;
                        else
                            valor_rest_lb = round(-2*pi,dec_redondeo);
                            valor_rest_ub = round(2*pi,dec_redondeo);
                            this.lb(indice_desde:indice_hasta) = valor_rest_lb;
                            this.ub(indice_desde:indice_hasta) = valor_rest_ub;
                        end
                    case 'VariableAuxiliar'
                        switch this.UnidadesVarOpt{i}
                            case 'P'
                                % potencia activa de líneas y
                                % transformadores o energia no
                                % suministrada
                                indice_desde = this.VarOpt(i).entrega_varopt_operacion('P', 1, 1);
                                indice_hasta = this.VarOpt(i).entrega_varopt_operacion('P', 1, 2);
                                if isa(this.VarOpt(i), 'cLinea') || isa(this.VarOpt(i), 'cTransformador2D')
                                    sr = this.VarOpt(i).entrega_sr_pu();
                                    this.lb(indice_desde:indice_hasta) = -10*sr;
                                    this.ub(indice_desde:indice_hasta) = 10*sr;
                                end
                            otherwise
                                error = MException('cOPF:inicializa_variables',...
                                    ['Inconsistencia en los datos en variable auxiliar. Tipo ' this.UnidadesVarOpt{i} ' no corresponde']);
                                throw(error)
                        end
                    otherwise
                        error = MException('cOPF:inicializa_variables',...
                            ['Inconsistencia en los datos. Tipo de variable de control ' this.TipoVarOpt{i} ' no corresponde']);
                        throw(error)
                end
            end
        end
        
        function activa_restricciones_red(this)
            dec_redondeo = this.pParOpt.DecimalesRedondeo;
            for i = 1:length(this.VarOpt)             
                switch this.TipoVarOpt{i}
                    case 'VariableControl'
                        % nada
                    case 'VariableEstado'
                        % ángulo de las subestaciones
                        indice_desde = this.VarOpt(i).entrega_varopt_operacion('Theta',1,1);
                        indice_hasta = this.VarOpt(i).entrega_varopt_operacion('Theta',1,2);
                        if this.VarOpt(i).es_slack()
                            this.lb(indice_desde:indice_hasta) = 0;
                            this.ub(indice_desde:indice_hasta) = 0;
                        else
                            valor_rest_lb = round(-pi,dec_redondeo);
                            valor_rest_ub = round(pi,dec_redondeo);
                            this.lb(indice_desde:indice_hasta) = valor_rest_lb;
                            this.ub(indice_desde:indice_hasta) = valor_rest_ub;
                        end
                    case 'VariableAuxiliar'
                        switch this.UnidadesVarOpt{i}
                            case 'P'
                                % potencia activa de líneas y
                                % transformadores o energia no
                                % suministrada                                    
                                indice_desde = this.VarOpt(i).entrega_varopt_operacion('P', 1, 1);
                                indice_hasta = this.VarOpt(i).entrega_varopt_operacion('P', 1, 2);
                                if isa(this.VarOpt(i), 'cLinea') || isa(this.VarOpt(i), 'cTransformador2D')
                                    sr = this.VarOpt(i).entrega_sr_pu();
                                    this.lb(indice_desde:indice_hasta) = -sr;
                                    this.ub(indice_desde:indice_hasta) = sr;
                                end
                            otherwise
                                error = MException('cOPF:activa_restricciones_red',...
                                    ['Inconsistencia en los datos en variable auxiliar. Tipo ' this.UnidadesVarOpt{i} ' no corresponde']);
                                throw(error)
                        end
                    otherwise
                        error = MException('cOPF:activa_restricciones_red',...
                            ['Inconsistencia en los datos. Tipo de variable de control ' this.TipoVarOpt{i} ' no corresponde']);
                        throw(error)
                end
            end
        end        
        
        function actualiza_balance_energia(this, variable)
            cant_po = this.iCantPuntosOperacion;
            indice_eserie_p_desde = variable.entrega_varopt_operacion('P', 1, 1);
            indice_eserie_p_hasta = variable.entrega_varopt_operacion('P', 1, 2);

            bus1 = variable.entrega_se1();
            indice_eq_bus1_desde = bus1.entrega_indice_restriccion_balance_energia(1);
            indice_eq_bus1_hasta = bus1.entrega_indice_restriccion_balance_energia(2);
            bus2 = variable.entrega_se2();
            indice_eq_bus2_desde = bus2.entrega_indice_restriccion_balance_energia(1);
            indice_eq_bus2_hasta = bus2.entrega_indice_restriccion_balance_energia(2);

            this.Aeq(indice_eq_bus1_desde:indice_eq_bus1_hasta,indice_eserie_p_desde:indice_eserie_p_hasta) = this.Aeq(indice_eq_bus1_desde:indice_eq_bus1_hasta,indice_eserie_p_desde:indice_eserie_p_hasta) + diag(ones(cant_po,1))*-1;
            this.Aeq(indice_eq_bus2_desde:indice_eq_bus2_hasta,indice_eserie_p_desde:indice_eserie_p_hasta) = this.Aeq(indice_eq_bus2_desde:indice_eq_bus2_hasta,indice_eserie_p_desde:indice_eserie_p_hasta) + diag(ones(cant_po,1));
        end
        
        function agrega_balance_energia(this, bus)
            % Función sólo para utilizar con TNEP.
            cant_po = this.iCantPuntosOperacion;
            indice_eq_desde = this.iIndiceEq +1;
            indice_eq_hasta = this.iIndiceEq + cant_po;
            this.iIndiceEq = this.iIndiceEq +cant_po;
            
            bus.agrega_indice_restriccion_balance_energia(1, indice_eq_desde);
            bus.agrega_indice_restriccion_balance_energia(2, indice_eq_hasta);
            this.Aeq = [this.Aeq; zeros(cant_po,length(this.Fobj))];
            % Balance de potencia activa en bus
            %generadores
            pGeneradores = bus.entrega_generadores_despachables();
            if ~isempty(pGeneradores)
                error = MException('cOPF:agrega_balance_energia','Error de programación. Función no acepta generadores en nuevos buses');
                throw(error)
            end
                    
            elpar = bus.entrega_elementos_paralelos();
            if ~isempty(elpar)
                error = MException('cOPF:agrega_balance_energia','Error de programación. Función no acepta elementos paralelos en nuevos buses');
                throw(error)
            end
            this.beq(indice_eq_desde:indice_eq_hasta) = 0;
                
            pConsumos = bus.entrega_consumos();
            if ~isempty(pConsumos)
                error = MException('cOPF:agrega_balance_energia','Error de programación. Función no acepta consumos en nuevos buses');
                throw(error)
            end
            
            % elementos serie
            eserie = bus.entrega_elementos_serie();
            if ~isempty(eserie)
                error = MException('cOPF:agrega_balance_energia','Error de programación. Bus se acaba de agregar como variable independiente, por lo que aún no debiera tener elementos en serie conectados');
                throw(error)
            end
            
            if this.iNivelDebug > 0
                for oper = 1:cant_po
                    this.NombreEq{indice_eq_desde + oper - 1} = strcat('req_', num2str(indice_eq_desde + oper - 1), '_be_', 'B', num2str(bus.entrega_id()), '_O', num2str(oper));
                end
            end
        end

        
        function escribe_relaciones_flujos_angulos(this)
            cant_po = this.iCantPuntosOperacion;
            eserie = this.pSEP.entrega_elementos_serie();
            dec_redondeo = this.pParOpt.DecimalesRedondeo;
            for i = 1:length(eserie)
                indice_eq_desde = this.iIndiceEq +1;
                indice_eq_hasta = this.iIndiceEq + cant_po;
                this.iIndiceEq = this.iIndiceEq +cant_po;
            
                eserie(i).agrega_indice_restriccion_flujos_angulos(1, indice_eq_desde);
                eserie(i).agrega_indice_restriccion_flujos_angulos(2, indice_eq_hasta);
                
                id_eserie_desde = eserie(i).entrega_varopt_operacion('P', 1, 1);
                id_eserie_hasta = eserie(i).entrega_varopt_operacion('P', 1, 2);
                
                bus1 = eserie(i).entrega_se1();
                bus2 = eserie(i).entrega_se2();
                id_t1_desde = bus1.entrega_varopt_operacion('Theta', 1, 1);
                id_t1_hasta = bus1.entrega_varopt_operacion('Theta', 1, 2);
                id_t2_desde = bus2.entrega_varopt_operacion('Theta', 1, 1);
                id_t2_hasta = bus2.entrega_varopt_operacion('Theta', 1, 2);

                x = round(eserie(i).entrega_reactancia_pu(),dec_redondeo);
                
                this.Aeq(indice_eq_desde:indice_eq_hasta,id_eserie_desde:id_eserie_hasta) = this.Aeq(indice_eq_desde:indice_eq_hasta,id_eserie_desde:id_eserie_hasta) + diag(ones(cant_po,1))*x;
                this.Aeq(indice_eq_desde:indice_eq_hasta,id_t1_desde:id_t1_hasta) = this.Aeq(indice_eq_desde:indice_eq_hasta,id_t1_desde:id_t1_hasta) + diag(ones(cant_po,1))*-1;
                this.Aeq(indice_eq_desde:indice_eq_hasta,id_t2_desde:id_t2_hasta) = this.Aeq(indice_eq_desde:indice_eq_hasta,id_t2_desde:id_t2_hasta) + diag(ones(cant_po,1));
                %for oper = 1:cant_po
                %    this.Aeq(indice_eq_desde + oper - 1,id_eserie_desde + oper - 1) = x;
                %    this.Aeq(indice_eq_desde + oper - 1,id_t1_desde + oper - 1) = -1;
                %    this.Aeq(indice_eq_desde + oper - 1,id_t2_desde + oper - 1) = 1;
                %end
                this.beq(indice_eq_desde:indice_eq_hasta) = 0;
                
                if this.pParOpt.entrega_flujo_dc_con_perdidas()
                    % se agregan las pérdidas. Aún no está implementado
                    % porque introduce relaciones cuadráticas con los
                    % ángulos
                    % fórmula: r/(2x^2)*(t1-t2)^2
                    r = eserie(i).entrega_resistencia();
                    factor = r/(2*x^2);
                    error = MException('cDCOPF:escribe_relaciones_flujos_angulos','OPF DC con pérdidas aún no implementado');
                    throw(error)
                end
                
                if this.iNivelDebug > 0
                    id_par = eserie(i).entrega_indice_paralelo();
                    if isa(eserie(i), 'cLinea')
                        texto = 'L';
                    else
                        texto = 'Tr';
                    end
                    for oper = 1:cant_po
                        this.NombreEq{indice_eq_desde + oper - 1} = strcat('req_', num2str(indice_eq_desde + oper - 1), '_flujos_angulos', texto, num2str(id_par), ...
                            '_B', num2str(bus1.entrega_id()), '_', num2str(bus2.entrega_id()), '_O', num2str(oper));
                    end
                end
            end
        end

        function agrega_relaciones_flujos_angulos(this, variable)
            dec_redondeo = this.pParOpt.DecimalesRedondeo;
            cant_po = this.iCantPuntosOperacion;
            indice_eq_desde = this.iIndiceEq +1;
            indice_eq_hasta = this.iIndiceEq + cant_po;
            this.iIndiceEq = this.iIndiceEq +cant_po;
            
            variable.agrega_indice_restriccion_flujos_angulos(1, indice_eq_desde);
            variable.agrega_indice_restriccion_flujos_angulos(2, indice_eq_hasta);
            
            id_eserie_desde = variable.entrega_varopt_operacion('P', 1, 1);
            id_eserie_hasta = variable.entrega_varopt_operacion('P', 1, 2);
            bus1 = variable.entrega_se1();
            bus2 = variable.entrega_se2();
            id_t1_desde = bus1.entrega_varopt_operacion('Theta', 1, 1);
            id_t1_hasta = bus1.entrega_varopt_operacion('Theta', 1, 2);
            id_t2_desde = bus2.entrega_varopt_operacion('Theta', 1, 1);
            id_t2_hasta = bus2.entrega_varopt_operacion('Theta', 1, 2);

            x = round(variable.entrega_reactancia_pu(),dec_redondeo);
            this.Aeq = [this.Aeq; zeros(cant_po, length(this.Fobj))];
            this.Aeq(indice_eq_desde:indice_eq_hasta,id_eserie_desde:id_eserie_hasta) = this.Aeq(indice_eq_desde:indice_eq_hasta,id_eserie_desde:id_eserie_hasta) + diag(ones(cant_po,1))*x;
            this.Aeq(indice_eq_desde:indice_eq_hasta,id_t1_desde:id_t1_hasta) = this.Aeq(indice_eq_desde:indice_eq_hasta,id_t1_desde:id_t1_hasta) + diag(ones(cant_po,1))*-1;
            this.Aeq(indice_eq_desde:indice_eq_hasta,id_t2_desde:id_t2_hasta) = this.Aeq(indice_eq_desde:indice_eq_hasta,id_t2_desde:id_t2_hasta) + diag(ones(cant_po,1));
            
            %for oper = 1:cant_po
            %    this.Aeq(indice_eq_desde + oper - 1,id_eserie_desde + oper - 1) = x;
            %    this.Aeq(indice_eq_desde + oper - 1,id_t1_desde + oper - 1) = -1;
            %    this.Aeq(indice_eq_desde + oper - 1,id_t2_desde + oper - 1) = 1;
            %end
            this.beq(indice_eq_desde:indice_eq_hasta) = 0;
                
            if this.pParOpt.entrega_flujo_dc_con_perdidas()
                error = MException('cDCOPF:agrega_relaciones_flujos_angulos','OPF DC con pérdidas aún no implementado');
                throw(error)
            end
                
            if this.iNivelDebug > 0
            	id_par = variable.entrega_indice_paralelo();
                if isa(variable, 'cLinea')
                    texto = 'L';
                else
                    texto = 'Tr';
                end
                for oper = 1:cant_po
                    this.NombreEq{indice_eq_desde + oper - 1} = strcat('req_', num2str(indice_eq_desde + oper - 1), '_flujos_angulos', texto, num2str(id_par), ...
                        '_B', num2str(bus1.entrega_id()), '_', num2str(bus2.entrega_id()), '_O', num2str(oper));
                end
            end
        end
        
        function optimiza(this)
            if this.pParOpt.entrega_flujo_dc_con_perdidas()
                error = MException('cDCOPF:optimiza','OPF DC con pérdidas aún no implementado');
                throw(error)
            else
                if this.iNivelDebug > 1
                    prot = cProtocolo.getInstance;
                    prot.imprime_texto('Comienzo proceso optimizacion OPF DC');
                    if this.iNivelDebug > 2
                        prot.imprime_texto('Dimensiones del problema:');
                        prot.imprime_texto(strcat('Cantidad de variables de decision: ', num2str(length(this.VarOpt))));
                        prot.imprime_texto(strcat('Dimension de funcion objetivo: ', num2str(length(this.Fobj))));
                        [m, n] = size(this.Aineq);
                        prot.imprime_texto(strcat('Dimension matriz de desigualdad: ', num2str(m), 'x', num2str(n)));
                        prot.imprime_texto(strcat('Dimension vector de desigualdad: ', num2str(length(this.bineq))));
                        prot.imprime_texto(strcat('Cantidad desigualdades: ', num2str(this.iIndiceIneq)));
                        [m, n] = size(this.Aeq);
                        prot.imprime_texto(strcat('Dimension matriz de igualdad: ', num2str(m), 'x', num2str(n)));
                        prot.imprime_texto(strcat('Dimension vector de igualdad: ', num2str(length(this.beq))));
                        prot.imprime_texto(strcat('Cantidad igualdades: ', num2str(this.iIndiceEq)));
                        prot.imprime_texto(strcat('Dimension vector lb: ', num2str(length(this.lb))));
                        prot.imprime_texto(strcat('Dimension vector ub: ', num2str(length(this.ub))));
                    end
                end
                if strcmp(this.pParOpt.Solver, 'Intlinprog')
                    if this.iNivelDebug > 0
                        if this.iNivelDebug > 1
                            options = optimoptions('linprog','Display','iter');
                        else
                            options = optimoptions('linprog','Display','final');
                        end
                    else
                        options = optimoptions('linprog','Display','off');
                    end
                
                    if this.MuestraDetalleIteraciones
                        % fuerza mostrar el detalle de las iteraciones,
                        % independiente del nivel de debug
                        options = optimoptions('linprog','Display','iter');
                    end
                    
                    [this.ResOptimizacion, this.Fval,this.ExitFlag,this.Output,this.Lambda]= linprog(this.Fobj,this.Aineq,this.bineq,this.Aeq,this.beq,this.lb,this.ub, [], options);
                elseif strcmp(this.pParOpt.Solver, 'Xpress')
                    options = xprsoptimset(optimset('Display', 'off'));
                    if this.MuestraDetalleIteraciones
                        options = xprsoptimset(optimset('Display', 'iter'));
                    end
                    rtype = [repmat('L',[1 size(this.Aineq,1)]) repmat('E',[1 size(this.Aeq,1)])];
                    [this.ResOptimizacion,this.Fval,this.ExitFlag,this.Output] = xprslp(this.Fobj,[this.Aineq; this.Aeq], [this.bineq; this.beq], rtype, this.lb,this.ub, options);%, options);
                	
                else
                    error = MException('cDCOPF:optimiza',...
                                       ['Optimizador "' this.pParOpt.Solver ' no está implementado']);
                    throw(error)    
                end
                %redondea resultados
                this.ResOptimizacion = round(this.ResOptimizacion,this.pParOpt.DecimalesRedondeo);
            end
        end
        
		function escribe_resultados(this)
            %primero una función de chequeo
            sbase = cParametrosSistemaElectricoPotencia.getInstance.entrega_sbase();
            buses = this.pSEP.entrega_subestaciones();
            cant_po = this.iCantPuntosOperacion;
            for bus = 1:length(buses)
                %ángulo del bus
                se = buses(bus);
                id_se = se.entrega_id();
                indice_opt_desde = buses(bus).entrega_varopt_operacion('Theta', 1, 1);
                indice_opt_hasta = buses(bus).entrega_varopt_operacion('Theta', 1, 2);
                
                theta = this.ResOptimizacion(indice_opt_desde:indice_opt_hasta);                                    
                this.pResEvaluacion.AnguloSubestaciones(id_se, 1:cant_po) = theta'/pi*180;

                %generadores
                generadores = buses(bus).entrega_generadores_despachables();
                for gen = 1:length(generadores)
                    id_gen = generadores(gen).entrega_id_resultado_evaluacion();
                    costo_mwh = generadores(gen).entrega_costo_mwh();
                    indice_opt_desde = generadores(gen).entrega_varopt_operacion('P', 1, 1);
                    indice_opt_hasta = generadores(gen).entrega_varopt_operacion('P', 1, 2);
                    p_mw = this.ResOptimizacion(indice_opt_desde:indice_opt_hasta)*sbase;
                    if strcmp(this.pParOpt.entrega_tipo_problema(), 'Redespacho')
                        this.pResEvaluacion.CostoRedespacho = this.pResEvaluacion.CostoRedespacho + costo_mwh * p_mw;
                        p0 = generadores(gen).entrega_p0();
                        p_mw = p_mw + p0;
                    end
                    this.pResEvaluacion.GeneradoresDespachablesP(id_gen, :) = p_mw';
                    this.pResEvaluacion.CostoGeneracion = this.pResEvaluacion.CostoGeneracion + costo_mwh*p_mw;
                end

                %consumos                    
                consumos = buses(bus).entrega_consumos();
                for con = 1:length(consumos)
                    id_elred = consumos(con).entrega_id();

                    if this.pParOpt.considera_desprendimiento_carga()
                        indice_opt_desde = consumos(con).entrega_varopt_operacion('P', 1, 1);
                        indice_opt_hasta = consumos(con).entrega_varopt_operacion('P', 1, 2);
                        ens = this.ResOptimizacion(indice_opt_desde:indice_opt_hasta)*sbase;
                        this.pResEvaluacion.ENSConsumos(id_elred, :) = ens';
                    else
                        ens = 0;
                    end
                    if ~isempty(this.pAdmSc)
                        indice_perfil = consumos(con).entrega_indice_adm_escenario_perfil();
                        perfil = this.pAdmSc.entrega_perfil_consumo(indice_perfil);
                        indice_capacidad = consumos(con).entrega_indice_adm_escenario_capacidad(this.iEscenario);
                        capacidad = this.pAdmSc.entrega_capacidad_consumo(indice_capacidad, this.iEtapa);
                        p0 = capacidad*perfil;                        
                    else
                        % sólo un punto de operación
                        p0 = -consumos(con).entrega_p_const_nom(); %p0 tiene valor positivo
                    end

                    this.pResEvaluacion.ConsumosP(id_elred, :) = p0-ens';
                    if sum(ens) > 0
                        costo_desconexion = consumos(con).entrega_costo_desconexion_carga();
                        costo_ens = ens*costo_desconexion;
                        this.pResEvaluacion.CostoENS = this.pResEvaluacion.CostoENS + costo_ens;
                    end
                end

                generadores_ernc = buses(bus).entrega_generadores_res();
                for gen = 1:length(generadores_ernc)
                    id_gen = generadores_ernc(gen).entrega_id_resultado_evaluacion();
                    if ~isempty(this.pAdmSc)
                        if generadores_ernc(gen).entrega_evolucion_capacidad_a_futuro(this.iEscenario)
                            id_adm_sc = generadores_ernc(gen).entrega_indice_adm_escenario_capacidad(this.iEscenario);
                            capacidad = this.pAdmSc.entrega_capacidad_generador(id_adm_sc, this.iEtapa);
                            id_adm_sc = generadores_ernc(gen).entrega_indice_adm_escenario_perfil_ernc();
                            pnom = capacidad*this.pAdmSc.entrega_perfil_ernc(id_adm_sc);
                        else
                            pnom = generadores_ernc(gen).entrega_p_const_nom_opf()*sbase;
                        end
                    else
                        pnom = generadores_ernc(gen).entrega_p_const_nom_opf()*sbase;
                    end

                    p_mw_recorte = zeros(cant_po,1);
                    if this.pParOpt.ConsideraRecorteRES
                        indice_opt_desde = generadores_ernc(gen).entrega_varopt_operacion('P', 1, 1);
                        indice_opt_hasta = generadores_ernc(gen).entrega_varopt_operacion('P', 1, 2);
                        p_mw_recorte = this.ResOptimizacion(indice_opt_desde:indice_opt_hasta)*sbase;
                        this.pResEvaluacion.RecorteGeneradoresRES(id_gen, :) = p_mw_recorte';
                        if sum(p_mw_recorte) > 0
                            penalizacion = this.pParOpt.entrega_penalizacion_recorte_res(); % en $/MWh
                            costo_recorte = p_mw_recorte*penalizacion;
                            this.pResEvaluacion.CostoRecorteGeneradoresRES = this.pResEvaluacion.CostoRecorteGeneradoresRES + costo_recorte;
                        end
                    end
                    this.pResEvaluacion.GeneradoresRESP(id_gen, :) = pnom - p_mw_recorte';
                end

                %lineas y trafos
                eserie = buses(bus).entrega_elementos_serie();
                for j = 1:length(eserie)                    
                    bus1 = eserie(j).entrega_se1();
                    if bus1 ~= buses(bus)
                        %Sólo para bus inicial para no repetir
                        continue;
                    end
                    indice_opt_desde = eserie(j).entrega_varopt_operacion('P', 1, 1);
                    indice_opt_hasta = eserie(j).entrega_varopt_operacion('P', 1, 2);
                    sr = eserie(j).entrega_sr();
                    flujo_p = this.ResOptimizacion(indice_opt_desde:indice_opt_hasta)*sbase;
                    porcentaje_uso = abs(flujo_p)/sr;
                    id_elred = eserie(j).entrega_id();
                    if isa(eserie(j), 'cLinea')
                        this.pResEvaluacion.FlujoLineasP(id_elred, :) = flujo_p';
%                         if eserie(j).tiene_flag_observacion()
%                             if min(porcentaje_uso) > this.pParOpt.PorcentajeUsoFlujosAltos
%                                 this.pResEvaluacion.inserta_linea_flujo_maximo(eserie(j), max(porcentaje_uso));
%                             elseif max(porcentaje_uso) < this.pParOpt.PorcentajeUsoFlujosBajos % bajo flujo
%                                 this.pResEvaluacion.inserta_linea_poco_uso(eserie(j), min(porcentaje_uso));
%                             end
%                         end
                    elseif  isa(eserie(j), 'cTransformador2D')
                        this.pResEvaluacion.FlujoTransformadoresP(id_elred, :) = flujo_p';
%                         if eserie(j).tiene_flag_observacion()
%                             if min(porcentaje_uso) > this.pParOpt.PorcentajeUsoFlujosAltos % flujo por trafo mayor al 95%
%                                 this.pResEvaluacion.inserta_trafo_flujo_maximo(eserie(j), max(porcentaje_uso));
%                             elseif max(porcentaje_uso) < this.pParOpt.PorcentajeUsoFlujosBajos % bajo flujo
%                                 this.pResEvaluacion.inserta_trafo_poco_uso(eserie(j), min(porcentaje_uso));
%                             end
%                         end
                    else
                        error = MException('cDCOPF:escribe_resultados',...
                                ['Tipo elemento (' class(eserie(j)) ' aún no implementado']);
                        throw(error)
                    end
                end % fin elementos serie
            end %fin buses
            
            if this.InsertaResultadosEnSEP
                this.pResEvaluacion.inserta_resultados_en_sep();
            end
        end

        function imprime_resultados_protocolo(this)
            dec_redondeo = this.pParOpt.DecimalesRedondeo;
            
            prot = cProtocolo.getInstance;
            sbase = cParametrosSistemaElectricoPotencia.getInstance.entrega_sbase();
            if this.iNivelDebug > 1
                prot.imprime_texto('');
                prot.imprime_texto('Resultados DC-OPF');
                prot.imprime_texto('Resultado variables optimizacion');
                for i = 1:length(this.ResOptimizacion)
                    texto = sprintf('%10s %5s %35s %3s %10s %5s %10s ', ...
                        num2str(this.lb(i)), '<=', this.NombreVariables{i}, '=', ...
                        num2str(this.ResOptimizacion(i)), '<=', num2str(this.ub(i)));
                    prot.imprime_texto(texto);
                end
            end
            
            prot.imprime_texto(['Etapa: ' num2str(this.iEtapa)]);
            for oper = 1:this.iCantPuntosOperacion
                prot.imprime_texto(['PO: ' num2str(oper)]);
                prot.imprime_texto('Balance de energia');
                texto = sprintf('%-15s %-15s %-10s %-10s %-10s %-10s %-10s %-10s %-10s', 'Subestacion', 'Generacion', 'ERNC', 'Consumo', 'Spill', 'ENS', 'Pin', 'Pout', 'Balance');
                prot.imprime_texto(texto);

                gen_total_oper = 0;
                res_total_oper = 0;
                consumo_total_oper = 0;
                spill_total_oper = 0;
                ens_total_oper = 0;
                
                buses = this.pSEP.entrega_subestaciones();
                for bus = 1:length(buses)
                	suma_gen = 0;
                    suma_capacidad_gen = 0;
                    generadores = buses(bus).entrega_generadores_despachables();
                    for gen = 1:length(generadores)
                        indice_opt = generadores(gen).entrega_varopt_operacion('P', 1, 1) + oper - 1;
                        p_mw = this.ResOptimizacion(indice_opt)*sbase;
                        if strcmp(this.pParOpt.entrega_tipo_problema(), 'Redespacho')
                            p0 = generadores(gen).entrega_p0();
                            p_mw = p_mw + p0;
                        end
                        if ~isempty(this.pAdmSc)
                            if generadores(gen).entrega_evolucion_capacidad_a_futuro(this.iEscenario)
                                id_adm_sc = generadores(gen).entrega_indice_adm_escenario_capacidad(this.iEscenario);
                                pmax = this.pAdmSc.entrega_capacidad_generador(id_adm_sc, etapa);
                            else
                                pmax = generadores(gen).entrega_pmax();
                            end
                        else
                            pmax = generadores(gen).entrega_pmax();
                        end
                        suma_capacidad_gen = suma_capacidad_gen + pmax;
                        suma_gen = suma_gen + p_mw;
                    end
                    
                    % generadores RES
                    spill = 0;
                    gen_res = 0;
                    generadores_ernc = buses(bus).entrega_generadores_res();
                    for gen = 1:length(generadores_ernc)
                        if ~isempty(this.pAdmSc)
                            if generadores_ernc(gen).entrega_evolucion_capacidad_a_futuro(this.iEscenario)
                                id_adm_sc = generadores_ernc(gen).entrega_indice_adm_escenario_capacidad(this.iEscenario);
                                capacidad = this.pAdmSc.entrega_capacidad_generador(id_adm_sc, this.iEtapa);
                                id_adm_sc = generadores_ernc(gen).entrega_indice_adm_escenario_perfil_ernc();
                                perfil = this.pAdmSc.entrega_perfil_ernc(id_adm_sc);
                                pnom = capacidad*perfil(oper);
                            else
                                pnom = generadores_ernc(gen).entrega_p_const_nom_opf()*sbase;
                            end
                        else
                            pnom = generadores_ernc(gen).entrega_p_const_nom_opf()*sbase;
                        end

                        gen_res = gen_res + pnom;
                        if this.pParOpt.ConsideraRecorteRES
                            indice_opt = generadores_ernc(gen).entrega_varopt_operacion('P', 1, 1) + oper - 1;
                            p_mw_recorte = this.ResOptimizacion(indice_opt)*sbase;
                            spill = spill + p_mw_recorte;
                        end
                    end
                                        
                    %consumos
                    p_consumo_nom = 0;
                    p_ens = 0;
                    consumos = buses(bus).entrega_consumos();
                    for con = 1:length(consumos)
                        if this.pParOpt.considera_desprendimiento_carga()
                            indice_opt = consumos(con).entrega_varopt_operacion('P', 1, 1) + oper - 1;
                            ens = this.ResOptimizacion(indice_opt)*sbase;
                        else
                            ens = 0;
                        end
                        if ~isempty(this.pAdmSc)
                            indice_perfil = consumos(con).entrega_indice_adm_escenario_perfil();
                            perfil = this.pAdmSc.entrega_perfil_consumo(indice_perfil);
                            indice_capacidad = consumos(con).entrega_indice_adm_escenario_capacidad(this.iEscenario);
                            capacidad = this.pAdmSc.entrega_capacidad_consumo(indice_capacidad, this.iEtapa);
                            p0 = capacidad*perfil(oper);
                        else
                            % sólo un punto de operación
                            p0 = -consumos(con).entrega_p_const_nom(); %p0 tiene valor positivo
                        end
                            
                        p_consumo_nom = p_consumo_nom + p0;
                        p_ens = p_ens + ens;
                    end
                    
                    %lineas y trafos
                    pin = 0;
                    pout = 0;
                    eserie = buses(bus).entrega_elementos_serie();
                    for j = 1:length(eserie)                    
                        bus1 = eserie(j).entrega_se1();
                        if bus1 == buses(bus)
                            signo = -1;
                        else
                            signo = 1;
                        end
                        
                        indice_opt = eserie(j).entrega_varopt_operacion('P', 1, 1) + oper - 1;
                        flujo_p = this.ResOptimizacion(indice_opt)*sbase;
                        if signo*flujo_p < 0
                        	pout = pout - signo*flujo_p;
                        else
                        	pin = pin + signo*flujo_p;
                        end                        
                    end % fin elementos serie

                    gen_total_oper = gen_total_oper + suma_gen;
                    res_total_oper = res_total_oper + gen_res;
                    consumo_total_oper = consumo_total_oper + p_consumo_nom;
                    spill_total_oper = spill_total_oper + spill;
                    ens_total_oper = ens_total_oper + p_ens;
                    
                    texto_generacion = [num2str(suma_gen) '/' num2str(suma_capacidad_gen)];
                    texto = sprintf('%-15s %-15s %-10s %-10s %-10s %-10s %-10s %-10s %-10s', buses(bus).entrega_nombre(), ...
                    	texto_generacion,...
                        num2str(round(gen_res,dec_redondeo)),...
                        num2str(round(p_consumo_nom,dec_redondeo)),...
                        num2str(round(spill,dec_redondeo)),...
                        num2str(round(p_ens,dec_redondeo)),...
                        num2str(round(pin,dec_redondeo)),...
                        num2str(round(pout,dec_redondeo)),...
                        num2str(round(suma_gen-p_consumo_nom+p_ens-spill+pin-pout,dec_redondeo)));
                    prot.imprime_texto(texto);
                end %fin buses

                texto = sprintf('%-15s %-15s %-10s %-10s %-10s %-10s %-10s %-10s %-10s', 'Total', ...
                    num2str(round(gen_total_oper,dec_redondeo)),...
                    num2str(round(res_total_oper,dec_redondeo)),...
                    num2str(round(consumo_total_oper,dec_redondeo)),...
                    num2str(round(spill_total_oper,dec_redondeo)),...
                    num2str(round(ens_total_oper,dec_redondeo)),...
                    '-',...
                    '-',...
                    '-');
                prot.imprime_texto(texto);
                
                % ahora se imprimen los resultados por subestación detallando
                % las líneas/trafos
                prot.imprime_texto('');
                prot.imprime_texto('Detalle de flujos por subestacion');
                texto = sprintf('%-25s %-15s %-15s %-7s %-8s %-8s %-8s %-8s %-8s %-8s %-25s', ...
                        'Linea', 'SE1', 'SE2', 'Signo', 'T1grad', 'T2grad', 'T1-T2', 'Xel', 'PMW', 'Pmax', 'Dif.calculado');
                prot.imprime_texto(texto);
                for bus1 = 1:length(buses)
                    eserie = buses(bus1).entrega_elementos_serie();
                    for bus2 = bus1+1:length(buses)
                        for j = 1:length(eserie)
                            bus_inicial = eserie(j).entrega_se1();
                            bus_final = eserie(j).entrega_se2();
                            
                            if bus_inicial ~= buses(bus2) && bus_final ~= buses(bus2)
                                continue;
                            end
                                indice_eserie_p = eserie(j).entrega_varopt_operacion('P', 1, 1) + oper - 1;
                                p_serie = this.ResOptimizacion(indice_eserie_p)*sbase;
                                sr = eserie(j).entrega_sr();
                                
                            	indice_bus1 = buses(bus1).entrega_varopt_operacion('Theta',1, 1) + oper - 1;
                                t1 = this.ResOptimizacion(indice_bus1);
                                indice_bus2 = buses(bus2).entrega_varopt_operacion('Theta',1, 1) + oper - 1;
                                t2 = this.ResOptimizacion(indice_bus2);

                                if bus_inicial == buses(bus1)
                                    signo = 1; % linea va de SE1 a SE2 por lo que flujo sale de la subestacion
                                else
                                    signo = -1;
                                end
                                x = eserie(j).entrega_reactancia_pu();
                                angulo_1 = round(t1/pi*180,dec_redondeo);
                                angulo_2 = round(t2/pi*180,dec_redondeo);
                                        
                                diff_angulo = round((t1-t2)/pi*180,dec_redondeo);
                                diff_calculado = signo*(t1-t2)/x*sbase;
                                diff_calculado = diff_calculado-p_serie;
                                texto = sprintf('%-25s %-15s %-15s %-7s %-8s %-8s %-8s %-8s %-8s %-8s %-25s', ...
                                        eserie(j).entrega_nombre(), ...
                                        buses(bus1).entrega_nombre(), ...
                                        buses(bus2).entrega_nombre(), ...
                                        num2str(signo), ...
                                        num2str(round(angulo_1,dec_redondeo)), ...
                                        num2str(round(angulo_2,dec_redondeo)), ...
                                        num2str(round(diff_angulo,dec_redondeo)), ...
                                        num2str(round(x,dec_redondeo)), ...
                                        num2str(round(p_serie,dec_redondeo)), ...
                                        num2str(round(sr,dec_redondeo)), ...
                                        num2str(round(diff_calculado,dec_redondeo)));
                                    prot.imprime_texto(texto);
                        end
                    end %fin subestaciones
                end % fin puntos de operación
            end
        end
        
        function evaluacion = entrega_evaluacion(this)
            evaluacion = this.pResEvaluacion;
        end
        
        function imprime_problema_optimizacion(this, varargin)
            % varargin indica el nombre del documento donde se quiere
            % imprimir. Si no se indica nada, entonces lo imprime con un
            % nombre predeterminado
            % sólo en modo debug. imprime el problema en archivo externo
            % determina nombre de variables de optimización
            % esto se hace sólo aquí, para no afectar la performance del
            % programa con datos que no se necesitan
            %[NombreIneq, NombreEq] = this.escribe_nombre_restricciones();
            
            if nargin > 1
                nombre_documento = varargin{1};
            else
                nombre_documento = [this.nombre_archivo_problema_opt '_' this.caso_estudio '_' num2str(this.iEtapa)];
            end
            docID = fopen(nombre_documento,'w');
            fprintf(docID, 'Formulacion matematica OPF\n');
            fprintf(docID, ['Tipo problema : ' this.pParOpt.entrega_tipo_problema()]);
            fprintf(docID, ['\nFuncion objetivo: ' this.pParOpt.entrega_funcion_objetivo()]);
            fprintf(docID, ['\nTipo flujo de potencia: ' this.pParOpt.entrega_tipo_flujo()]);
            fprintf(docID, ['\nTipo restricciones seguridad: ' this.pParOpt.entrega_tipo_restricciones_seguridad()]);
            if this.pParOpt.entrega_flujo_dc_con_perdidas()
            	val = 'si';
            else
            	val = 'no';
            end
                fprintf(docID, ['\nConsidera pérdidas: ' val]);
            fprintf(docID, '\n');
            
            fprintf(docID, 'Funcion objetivo\n');
            primero = true;
            for i = 1:length(this.Fobj)
                if this.Fobj(i) ~= 0
                    val = round(this.Fobj(i),3);                    
                    if primero
                        text = strcat(num2str(val),'(',this.NombreVariables{i},')');
                        primero = false;
                    else
                        if this.Fobj(i) > 0
                            text = strcat(text, ' + ',num2str(val),'(', this.NombreVariables{i},')');
                        else
                            text = strcat(text, ' - ',num2str(abs(val)),'(',this.NombreVariables{i},')');
                        end
                        if length(text) > 170
                            text = strcat(text,'\n');
                            fprintf(docID, text);
                            primero = true;
                        end
                    end
                end
            end
            text = strcat(text,'\n');
            fprintf(docID, text);
            % restricciones
            % restricciones de desigualdad
            if ~isempty(this.bineq)
                fprintf(docID, 'Restricciones de desigualdad:\n');
            end
            
            for i = 1:length(this.bineq)    
                nombre_ineq = this.NombreIneq{i};
                fprintf(docID, strcat(nombre_ineq,':\n'));
                primero = true;
                for j = 1:length(this.VarOpt)
                    if this.Aineq(i,j) ~= 0
                        val = this.Aineq(i,j);                    
                        if primero
                            if val == 1
                                text = strcat('(',this.NombreVariables{j},')');
                            elseif val == -1
                                text = strcat('-', '(' ,this.NombreVariables{j}, ')');
                            else
                                text = strcat(num2str(val), '(', this.NombreVariables{j}, ')');
                                %error = MException('cMILPOpt:imprime_problema_optimizacion','valor restriccion de desigualdad debe ser 1 o -1');
                                %throw(error)
                            end
                            primero = false;
                        else
                            if val == 1
                                text = strcat(text, ' + ', '(', this.NombreVariables{j}, ')');
                            elseif val == -1
                                text = strcat(text, ' - ', '(', this.NombreVariables{j}, ')');
                            elseif val > 0
                                text = strcat(text, ' + ', num2str(val), '(', this.NombreVariables{j}, ')');
                            else
                                text = strcat(text, ' - ', num2str(abs(val)), '(', this.NombreVariables{j}, ')');
                                %error = MException('cMILPOpt:imprime_problema_optimizacion','valor restriccion de desigualdad debe ser 1 o -1');
                                %throw(error)
                            end
                            if length(text) > 170
                                text = strcat(text,'\n');
                                fprintf(docID, text);
                                primero = true;
                            end
                        end
                    end
                end
                text = strcat(text,' <= ', num2str(this.bineq(i)),'\n\n');
                fprintf(docID, text);
            end

            fprintf(docID, 'Restricciones de igualdad:\n');
            for i = 1:length(this.beq)
                nombre_eq = this.NombreEq{i};

                fprintf(docID, strcat(nombre_eq,':\n'));
                primero = true;
                [~, id] = find(this.Aeq(i,:));
                if isempty(id)
                    error = MException('cDCOPF:imprime_problema_optimizacion',...
                                       ['Inconsistencia en los datos. Ecuación de igualdad ' nombre_eq ' no tiene variables activas']);
                    throw(error)
                end
                
                for kk = 1:length(id)
                    id_var = id(kk);
                    val = this.Aeq(i,id_var);
                    if primero
                        if val == 1
                            text = strcat(this.NombreVariables{id_var});
                        elseif val == -1
                            text = strcat('-',this.NombreVariables{id_var});
                        elseif val > 0
                            text = strcat(num2str(round(val,3)),'*',this.NombreVariables{id_var});
                        else
                            text = strcat('-', num2str(abs(round(val,3))),'*',this.NombreVariables{id_var});
                        end
                        primero = false;
                    else
                        if val == 1
                            text = strcat(text, ' + ',this.NombreVariables{id_var});
                        elseif val == -1
                            text = strcat(text, ' - ',this.NombreVariables{id_var});
                        elseif val > 0
                            text = strcat(text, ' + ', num2str(round(val,3)),'*',this.NombreVariables{id_var});
                        else
                            text = strcat(text, ' - ', num2str(abs(round(val,3))),'*',this.NombreVariables{id_var});
                        end
                        if length(text) > 170
                            text = strcat(text,'\n');
                            fprintf(docID, text);
                            primero = true;
                        end
                    end
                end
                text = strcat(text,' = ', num2str(this.beq(i)),'\n\n');
                fprintf(docID, text);
            end
            
            % límites de las variables
            fprintf(docID, 'Limites variables de decision:\n');
            for i = 1:length(this.Fobj)
                text = strcat(num2str(this.lb(i)), ' <= ', this.NombreVariables{i}, ' <= ', num2str(this.ub(i)), '\n');
                fprintf(docID, text);
            end
            fprintf(docID, 'fin');
            fclose(docID);
        end
        
        function inserta_varopt(this, vector, tipo_variable, unidades)
            if ~isempty(vector)
                pos = length(this.VarOpt);
                this.VarOpt = [this.VarOpt; vector];
                for i = 1:length(vector)
                    vector(i).inserta_pos_varopt(pos + i);
                    this.TipoVarOpt{end+1} = tipo_variable;
                    this.UnidadesVarOpt{end+1} = unidades;
                end
            end
        end

        function agrega_varopt(this, variable, tipo_variable, unidades)
            this.VarOpt = [this.VarOpt; variable];
            id = length(this.VarOpt);
            variable.inserta_pos_varopt(id);
            this.TipoVarOpt{id} = tipo_variable;
            this.UnidadesVarOpt{id} = unidades;
        end
        
        function ingresa_nombres(this, indice_varopt, indice_global_desde, tipo_varopt, unidades_varopt)
            switch tipo_varopt
                case 'VariableControl'
                    if strcmp(unidades_varopt, 'P')
                        % Se trata de un generador                        
                        id_bus = this.VarOpt(indice_varopt).entrega_se().entrega_id();
                        for oper = 1:this.iCantPuntosOperacion
                            indice_nombre = indice_global_desde + oper -1;
                            texto = strcat('P_G', num2str(this.VarOpt(indice_varopt).entrega_id()), ...
                                           '_B', num2str(id_bus), '_O', num2str(oper));
                            this.NombreVariables{indice_nombre} = texto;
                        end
                    else
                        error = MException('cOPF:ingresa_nombres',...
                                           ['Inconsistencia en los datos. Tipo de variable unidad en variable de control '...
                                             unidades_varopt ' no implementada']);
                        throw(error)
                    end
                case 'VariableEstado'
                    if strcmp(unidades_varopt, 'Theta')
                        id_bus = this.VarOpt(indice_varopt).entrega_id();
                        for oper = 1:this.iCantPuntosOperacion
                            indice_nombre = indice_global_desde + oper -1;
                            texto = strcat('Theta_B', num2str(id_bus), ...
                                           '_O', num2str(oper));
                            this.NombreVariables{indice_nombre} = texto;
                        end
                    else
                        error = MException('cOPF:ingresa_nombres',...
                                           ['Inconsistencia en los datos. Tipo de variable unidad en variable de estado '...
                                             unidades_varopt ' no implementada']);
                        throw(error)
                    end
                case 'VariableAuxiliar'
                    if strcmp(unidades_varopt, 'P')
                        % Potencia activa en una línea o un trafo o consumo
                        if isa(this.VarOpt(indice_varopt), 'cConsumo')
                            id_consumo = this.VarOpt(indice_varopt).entrega_id();
                            id_global_bus = this.VarOpt(indice_varopt).entrega_se().entrega_id();
                            for oper = 1:this.iCantPuntosOperacion
                                indice_nombre = indice_global_desde + oper -1;
                                texto = strcat('ENS_C', num2str(id_consumo), ...
                                               '_B', num2str(id_global_bus), ...
                                               '_O', num2str(oper));
                                this.NombreVariables{indice_nombre} = texto;
                            end
                        elseif isa(this.VarOpt(indice_varopt), 'cTransformador2D') || isa(this.VarOpt(indice_varopt), 'cLinea')
                            id_par = this.VarOpt(indice_varopt).entrega_indice_paralelo();
                            id_global_bus1 = this.VarOpt(indice_varopt).entrega_se1().entrega_id();
                            id_global_bus2 = this.VarOpt(indice_varopt).entrega_se2().entrega_id();
                            if isa(this.VarOpt(indice_varopt), 'cLinea')
                                tipo_cond = this.VarOpt(indice_varopt).entrega_tipo_conductor();
                            else
                                tipo_cond = this.VarOpt(indice_varopt).entrega_tipo_trafo();
                            end
                            if isa(this.VarOpt(indice_varopt), 'cLinea')
                                for oper = 1:this.iCantPuntosOperacion
                                    indice_nombre = indice_global_desde + oper -1;
                                    texto = strcat('P_L', num2str(id_par), ...
                                                   '_C', num2str(tipo_cond), ...
                                                   '_B', num2str(id_global_bus1), ...
                                                   '_', num2str(id_global_bus2), ...
                                                   '_O', num2str(oper));
                                    this.NombreVariables{indice_nombre} = texto;
                                end
                            elseif isa(this.VarOpt(indice_varopt), 'cTransformador2D')
                                for oper = 1:this.iCantPuntosOperacion
                                    indice_nombre = indice_global_desde + oper -1;
                                    texto = strcat('P_T', num2str(id_par), ...
                                                   '_Tipo', num2str(tipo_cond), ... 
                                                   '_B', num2str(id_global_bus1), ...
                                                   '_', num2str(id_global_bus2), ...
                                                   '_O', num2str(oper));
                                    this.NombreVariables{indice_nombre} = texto;
                                end
                            end
                        elseif isa(this.VarOpt(indice_varopt), 'cGenerador')
                            % se trata de un generador ERNC
                            id_bus = this.VarOpt(indice_varopt).entrega_se().entrega_id();
                            for oper = 1:this.iCantPuntosOperacion
                                indice_nombre = indice_global_desde + oper -1;
                                texto = strcat('PC_G', num2str(this.VarOpt(indice_varopt).entrega_id()), ...
                                               '_B', num2str(id_bus), '_O', num2str(oper));
                                this.NombreVariables{indice_nombre} = texto;
                            end
                        else
                        	error = MException('cOPF:ingresa_nombres',...
                                               ['Inconsistencia en los datos. Tipo elemento de red ' ...
                                               class(this.VarOpt(indice_varopt))...
                                               ' no está implementado en variable auxiliar y tipo variable P']);
                            throw(error)
                        end
                    elseif strcmp(unidades_varopt, 'Error_pos') || strcmp(unidades_varopt, 'Error_neg')
                        % puede ser una línea, un trafo 
                        id_par = this.VarOpt(indice_varopt).entrega_indice_paralelo();
                        if isa(this.VarOpt(indice_varopt), 'cLinea')
                            id_global_bus1 = this.VarOpt(indice_varopt).entrega_se1().entrega_id();
                            id_global_bus2 = this.VarOpt(indice_varopt).entrega_se2().entrega_id();
                            tipo_cond = this.VarOpt(indice_varopt).entrega_tipo_conductor();
                            for oper = 1:this.iCantPuntosOperacion
                                indice_nombre = indice_global_desde + oper -1;
                                texto = strcat(unidades_varopt, '_P_L', num2str(id_par), ...
                                               '_C', num2str(tipo_cond), ...
                                               '_B', num2str(id_global_bus1), ...
                                               '_', num2str(id_global_bus2), ...
                                               '_O', num2str(oper));
                                this.NombreVariables{indice_nombre} = texto;
                            end
                        elseif isa(this.VarOpt(indice_varopt), 'cTransformador2D')
                            id_global_bus1 = this.VarOpt(indice_varopt).entrega_se1().entrega_id();
                            id_global_bus2 = this.VarOpt(indice_varopt).entrega_se2().entrega_id();
                            for oper = 1:this.iCantPuntosOperacion
                                indice_nombre = indice_global_desde + oper -1;
                                texto = strcat(unidades_varopt, '_P_Tr', num2str(id_par), ...
                                               '_B', num2str(id_global_bus1), ...
                                               '_', num2str(id_global_bus2), ...
                                               '_O', num2str(oper));
                                this.NombreVariables{indice_nombre} = texto;
                            end
                        else
                            error = MException('cOPF:ingresa_nombres',...
                                               ['Inconsistencia en los datos. Tipo elemento de red ' ...
                                               class(this.VarOpt(indice_varopt))...
                                               ' no está implementado en variable auxiliar y tipo variable Q']);
                            throw(error)
                        end
                    else
                        error = MException('cOPF:ingresa_nombres',...
                                           ['Inconsistencia en los datos. Tipo de variable auxiliar con tipo de estado '...
                                             unidades_varopt ' no implementada']);
                        throw(error)
                    end                        
                otherwise
                        error = MException('cOPF:ingresa_nombres',...
                                           ['Inconsistencia en los datos. Tipo de variable '...
                                             tipo_varopt ' no implementada']);
                        throw(error)
            end
        end
        
        function copia_parametros_optimizacion(this, parametros)
            this.pParOpt.FuncionObjetivo = parametros.FuncionObjetivo;
            this.pParOpt.TipoFlujoPotencia = parametros.TipoFlujoPotencia;
            this.pParOpt.TipoRestriccionesSeguridad = parametros.TipoRestriccionesSeguridad;
            this.pParOpt.ConsideraDesprendimientoCarga = parametros.considera_desprendimiento_carga();
            this.pParOpt.PenalizacionRecorteRES = parametros.PenalizacionRecorteRES;
            this.pParOpt.Solver = parametros.Solver;
            
            this.iNivelDebug = parametros.NivelDebugOPF;
        end
        
        function ingresa_nombres_problema(this)
            this.NombreVariables = cell(length(this.VarOpt)*this.iCantPuntosOperacion,1);
            for i = 1:length(this.VarOpt)
                switch this.TipoVarOpt{i}
                    case 'VariableControl'
                        indice = this.VarOpt(i).entrega_varopt_operacion('P',1, 1);
                    case 'VariableEstado'
                        % ángulo de las subestaciones 
                        indice = this.VarOpt(i).entrega_varopt_operacion('Theta',1, 1);
                    case 'VariableAuxiliar'
                        switch this.UnidadesVarOpt{i}
                            case 'P'
                                % potencia activa de líneas y
                                % transformadores o energia no
                                % suministrada
                                indice = this.VarOpt(i).entrega_varopt_operacion('P',1, 1);
                        end
                end
                this.ingresa_nombres(i,indice, this.TipoVarOpt{i}, this.UnidadesVarOpt{i});
            end
            
            this.NombreEq = cell(this.iIndiceEq,1);
            pBuses = this.pSEP.entrega_subestaciones();
            eserie = this.pSEP.entrega_elementos_serie();
            for oper = 1:this.iCantPuntosOperacion
                for i = 1:length(pBuses)
                    id_restriccion_be = pBuses(i).entrega_indice_restriccion_balance_energia(1) + oper - 1;
                    this.NombreEq{id_restriccion_be} = strcat('req_', num2str(id_restriccion_be), '_be_', 'B', num2str(pBuses(i).entrega_id()), '_O', num2str(oper));
                end

                for i = 1:length(eserie)
                    id_restriccion = eserie(i).entrega_indice_restriccion_flujos_angulos(1) + oper - 1;
                    id_par = eserie(i).entrega_indice_paralelo();
                    bus1 = eserie(i).entrega_se1();
                    bus2 = eserie(i).entrega_se2();
                    if isa(eserie(i), 'cLinea')
                        texto = 'L';
                    else
                        texto = 'Tr';
                    end
                	this.NombreEq{id_restriccion} = strcat('req_', num2str(id_restriccion), '_flujos_angulos', texto, num2str(id_par), ...
                        '_B', num2str(bus1.entrega_id()), '_', num2str(bus2.entrega_id()), '_O', num2str(oper));
                end
            end     
        end
        
        function elimina_nombres_problema(this)
            this.NombreVariables = [];
            this.NombreIneq = [];
            this.NombreEq = [];
        end
        
        function muestra_detalle_iteraciones(this,val)
            this.MuestraDetalleIteraciones = val;
        end
        
        function inserta_solver(this,val)
            this.pParOpt.Solver = val;
        end
 	end
end